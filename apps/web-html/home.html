<!-- =============================================
 home.html (캐릭터 목록) — 상세 주석 버전
 구조: 헤더 <style>, 본문 레이아웃, 스크립트(데이터 로드/렌더)
 ============================================= -->
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>캐릭터 선택</title>
  <script src="/js/config.js"></script>
  <script src="/js/assets.js"></script>
  <script>
    // Cloudflare Pages 배포 환경에서 사용할 기본 API 엔드포인트
    window.API_BASE_URL = 'https://api.arcanaverse.ai';
    window.API_BASE = 'https://api.arcanaverse.ai';  // API_BASE도 함께 설정
  </script>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, 'Apple SD Gothic Neo','Malgun Gothic',sans-serif; background:#0b0f14; color:#e5e7eb;}

    /* top nav (moved from bottom) */
    .nav { position:sticky; top:0; z-index:30; background:#0b1118; border-bottom:1px solid #18212c; }
    .navin { max-width:1200px; margin:0 auto; padding:8px 12px; display:flex; align-items:center; gap:12px; }
    .navin .tabs { display:grid; grid-template-columns: repeat(5, 1fr); gap:12px; flex: 1; }
    .tab { text-align:center; padding:10px 8px; border-radius:10px; background:#0f172a; color:#a5b4fc; border:1px solid #1e293b; font-size:12px; cursor:pointer; user-select:none; }
    .tab:active { transform:translateY(1px); }

    .wrap { max-width:1200px; margin:24px auto 40px; padding:0 16px;}
    h1 { font-size:20px; font-weight:700; margin:8px 0 20px; color:#d1d5db; }
    
    /* 카테고리 탭 (두 번째 이미지 스타일) */
    .category-tabs { display:flex; gap:8px; margin-bottom:32px; padding-bottom:0; }
    .category-tab { 
      padding:10px 20px; 
      background:transparent; 
      border:none; 
      border-radius:12px;
      color:#94a3b8; 
      font-size:14px; 
      font-weight:500; 
      cursor:pointer; 
      transition:all .2s ease;
      position:relative;
    }
    .category-tab:hover { 
      color:#e5e7eb; 
      background:#1f2937;
    }
    .category-tab.active { 
      color:#ffffff; 
      background:#3b82f6;
      font-weight:600;
    }
    .category-tab.active:hover {
      background:#2563eb;
    }
    
    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap:18px; }
    .card { display:block; background:#111827; border-radius:14px; overflow:hidden; border:1px solid #1f2937; text-decoration:none; color:inherit; box-shadow:0 6px 18px rgba(0,0,0,.25); transition: transform .15s ease, box-shadow .15s ease; }
    .card:hover { transform:translateY(-2px); box-shadow:0 10px 24px rgba(0,0,0,.35); }
    .thumb { width:100%; aspect-ratio: 16/10; object-fit:cover; background:#0f172a; display:block; }
    .body { padding:12px 14px 16px; }
    .name { font-size:16px; font-weight:700; color:#f3f4f6; }
    .meta { margin-top:6px; font-size:12px; color:#94a3b8; line-height:1.4; display:block; height:32px; overflow:hidden; }

    /* toast layer */
    .toast { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; opacity:0; transition:opacity .18s ease; z-index:50; }
    .toast.show { opacity:1; }
    .toast .box { pointer-events:auto; min-width:200px; max-width:80vw; background:#0f172a; border:1px solid #1f2937; color:#e5e7eb; padding:14px 18px; border-radius:12px; box-shadow:0 12px 32px rgba(0,0,0,.45); text-align:center; }
  </style>
</head>
<body>
  <!-- Top Navigation -->
  <div class="nav"><div class="navin">
    <div class="tabs">
      <div class="tab" data-nav="logo">Logo</div>
      <a href="/search.html" class="tab" data-nav="search">Search</a>
      <a href="/create/index.html" class="tab" data-nav="create">Create</a>
      <div class="tab" data-nav="list">My List</div>
      <div class="tab" data-nav="my">My</div>
    </div>
  </div></div>

  <div class="wrap">
    <h1>캐릭터 선택</h1>

    <div class="category-tabs">
      <button class="category-tab active" data-category="characters">캐릭터 선택</button>
      <button class="category-tab" data-category="worlds">세계관 선택</button>
      <button class="category-tab" data-category="games">게임 선택</button>
    </div>
    <div id="grid" class="grid"></div>
  </div>

  <!-- Toast Layer -->
  <div id="toast" class="toast" aria-live="polite" aria-atomic="true">
    <div class="box">준비중입니다</div>
  </div>

  <script>
    // 절대경로 API_BASE_URL 상수 정의
    const API_BASE_URL =
      window.location.hostname === "arcanaverse.ai" ||
      window.location.hostname === "www.arcanaverse.ai"
        ? "https://api.arcanaverse.ai"
        : "http://localhost:8000";
    
    // API 실패 시 로컬 JSON 대체 경로(있다면 사용됨)
    const CANDIDATES = ['/json/characters.json','/characters.json','/static/characters.json'];

    // 검색/탭 공통 상태
    let currentCategory = 'characters';        // 'characters' | 'worlds' | 'games'
    let qInput = '';                           // 입력창 값
    let qApplied = '';                         // 실제 검색에 사용된 값
    let searchApplied = false;                 // 검색 실행 여부
    
    // 무한 스크롤 상태 (characters 전용) - 누적 상태 방식
    let allCharacters = [];  // 누적 배열
    let skip = 0;
    const limit = 60;
    let isLoading = false;
    let hasMore = true;
    let initialized = false;  // 초기화 여부
    const seenIds = new Set();  // 중복 방지 (id 기준)

        // 서버 API에서 캐릭터 목록 로드
    async function loadFromApi({ q = '', skip = 0, limit = 60 } = {}) {
      const params = new URLSearchParams();
      params.set('skip', String(skip));
      params.set('limit', String(limit));
      if (q && q.trim().length > 0) {
        params.set('q', q.trim());
      }

      const r = await fetch(`${API_BASE_URL}/v1/characters?${params.toString()}`, {
        method: "GET",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
      });
      if (!r.ok) throw new Error('HTTP ' + r.status);
      const j = await r.json();
      return j.items || [];
    }
    
    // 서버 API에서 세계관 목록 로드
    async function loadWorldsFromApi({ q = '', offset = 0, limit = 60 } = {}) {
      const params = new URLSearchParams();
      params.set('offset', String(offset));
      params.set('limit', String(limit));
      if (q && q.trim().length > 0) {
        params.set('q', q.trim());
      }

      const r = await fetch(`${API_BASE_URL}/v1/worlds?${params.toString()}`, {
        method: "GET",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
      });
      if (!r.ok) {
        const errorText = await r.text();
        console.error('[loadWorldsFromApi] HTTP error:', r.status, errorText);
        throw new Error('HTTP ' + r.status + ': ' + errorText);
      }
      const j = await r.json();
      console.log('[loadWorldsFromApi] Response:', j);
      // API 응답 구조: { items: [...], total: number, ... }
      const items = j.items || [];
      console.log('[loadWorldsFromApi] Items count:', items.length);
      return items;
    }
    
    // 서버 API에서 게임 목록 로드
    async function loadGamesFromApi({ q = '', offset = 0, limit = 60 } = {}) {
      const params = new URLSearchParams();
      params.set('offset', String(offset));
      params.set('limit', String(limit));
      if (q && q.trim().length > 0) {
        params.set('q', q.trim());
      }

      const r = await fetch(`${API_BASE_URL}/v1/games?${params.toString()}`, {
        method: "GET",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
      });
      if (!r.ok) {
        const errorText = await r.text();
        console.error('[loadGamesFromApi] HTTP error:', r.status, errorText);
        throw new Error('HTTP ' + r.status + ': ' + errorText);
      }
      const j = await r.json();
      console.log('[loadGamesFromApi] Response:', j);
      // API 응답 구조: { items: [...], total: number, ... }
      const items = j.items || [];
      console.log('[loadGamesFromApi] Items count:', items.length);
      return items;
    }
    
        // 로컬 정적 JSON에서 캐릭터 목록 로드 (개발/오프라인용)
    async function loadFromLocal(url) {
      const r = await fetch(url);
      if (!r.ok) throw new Error('HTTP ' + r.status);
      const j = await r.json();
      return j.characters || j.items || j || [];
    }
        // 캐릭터 목록 로드 진입점: 1) API 시도 → 2) 실패 시 로컬 JSON들 순차 시도
    async function loadCharacters(q = '') {
      try { return await loadFromApi({ q }); }
      catch(_) {
        for (const url of CANDIDATES) { try { return await loadFromLocal(url); } catch(__){} }
        return [];
      }
    }
    
    // 세계관 목록 로드
    async function loadWorlds(q = '') {
      try { 
        const items = await loadWorldsFromApi({ q });
        console.log('[loadWorlds] Success, items:', items.length);
        return items;
      } catch(error) {
        console.error('[loadWorlds] Error:', error);
        return [];
      }
    }
    
    // 게임 목록 로드
    async function loadGames(q = '') {
      try { 
        const items = await loadGamesFromApi({ q });
        console.log('[loadGames] Success, items:', items.length);
        return items;
      } catch(error) {
        console.error('[loadGames] Error:', error);
        return [];
      }
    }

        // 숫자/char_XX 형태를 일관된 char_## 로 통일
    function normalizeCharId(v){
      if(!v) return 'char_01';
      if(/^\d+$/.test(v)) return 'char_' + String(parseInt(v,10)).padStart(2,'0');
      if(/^char_\d{1,2}$/.test(v)) return 'char_' + String(parseInt(v.split('_')[1],10)).padStart(2,'0');
      return v;
    }

    // ✅ 목록 썸네일도 동일 로직
    function resolvePath(p){
      if (!p) return '/assets/img/placeholder.jpg';
      if (/^https?:\/\//i.test(p)) return p;
      p = String(p).replace(/\\/g, '/').trim();
      if (p.startsWith('/')) return p;
      if (p.startsWith('assets/')) return '/' + p;
      // 세계관 이미지 처리
      if (p.includes('/world/') || p.startsWith('world/') || p.startsWith('assets/world/')) {
        p = p.replace(/^assets\/?/, '');
        p = p.replace(/^world\//, 'world/');
        return '/assets/' + p;
      }
      // 캐릭터 이미지 처리
      if (p.includes('/char/') || p.startsWith('char/') || /^char_\d+/i.test(p) || p.startsWith('assets/char/')) {
        p = p.replace(/^assets\/?/, '');
        p = p.replace(/^char\//, 'char/');
        return '/assets/' + p;
      }
      return '/assets/img/' + p;
    }
    
    // 그리드 컨테이너 확실히 잡는 함수
    function getGridElement() {
      // 1) 기존에 쓰던 selector가 있다면 먼저 시도
      const byId = document.getElementById('grid');
      if (byId) return byId;

      // 2) 카드 하나를 기준으로 부모를 찾는다 (가장 안정적)
      const firstCard = document.querySelector('.card');
      if (firstCard && firstCard.parentElement) return firstCard.parentElement;

      console.error('[home] grid element not found');
      return null;
    }
    
    // 캐릭터 대표 이미지 URL 추출 함수 (안전한 fallback 보장)
    function getCharacterImageUrl(item) {
      const candidates = [
        item.image_url,
        item.thumbnail_url,
        item.portrait_url,
        item.cover_url,
        item.image,
        item.thumbnail,
        item.portrait,
        item.cover,
      ];

      const raw = candidates.find(Boolean);

      if (!raw) {
        console.warn('[home] character has no image, using placeholder', item.id || item.name);
        return '/assets/img/placeholder.jpg'; // 반드시 존재하는 기본 이미지
      }

      // 이미 전체 URL이면 정규화 후 반환
      if (typeof raw === 'string' && (raw.startsWith('http://') || raw.startsWith('https://'))) {
        // r2.dev 차단 및 정규화
        if (typeof window.normalizeAssetUrl === 'function') {
          return window.normalizeAssetUrl(raw);
        }
        return raw;
      }

      // path면 buildAssetUrl 사용
      const path = resolvePath(raw);
      if (typeof window.buildAssetUrl === 'function') {
        return window.buildAssetUrl(path);
      }
      // fallback: ASSET_BASE_URL 직접 사용
      const assetBase = window.ASSET_BASE_URL || 'https://img.arcanaverse.ai';
      return assetBase + (path.startsWith('/') ? path : '/' + path);
    }
    
    // 카드 HTML 문자열 생성 함수 (전체 재렌더용)
    function renderCard(item) {
      if (!item) {
        console.warn('[home] renderCard() called with null item');
        return '';
      }
      
      const id = normalizeCharId(item.id || item.pk || item.slug || item.name || 'char_01');
      const imageUrl = getCharacterImageUrl(item);
      const name = (item.name || id).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
      const metaText = (item.shortBio || item.oneLiner || item.greeting || item.summary || '').toString().replace(/"/g, '&quot;').replace(/'/g, '&#39;');
      const chips = [item.genre, item.style, item.world].filter(Boolean).map(v => 
        `<span style="font-size:11px;padding:2px 8px;border:1px solid #334155;border-radius:999px;background:#0b1220;color:#a5b4fc">${String(v).replace(/"/g, '&quot;')}</span>`
      ).join('');
      
      return `<a class="card" href="/chat?character=${id}" data-character-id="${id}">
        <img class="thumb" src="${imageUrl}" alt="${name}" loading="lazy" />
        <div class="body">
          <div class="name">${name}</div>
          <span class="meta">${metaText}</span>
          ${chips ? `<div style="margin-top:6px;display:flex;gap:6px;">${chips}</div>` : ''}
        </div>
      </a>`;
    }
    
    // 카드 DOM을 생성하여 그리드에 추가 (캐릭터용, null 반환 금지) - 기존 호환성 유지
    function card(item) {
      if (!item) {
        console.warn('[home] card() called with null item');
        return null;
      }
      
      const id = normalizeCharId(item.id || item.pk || item.slug || item.name || 'char_01');
      const a  = document.createElement('a');
      a.className = 'card';
      a.href = `/chat?character=${id}`;
      a.setAttribute('data-character-id', id);
      a.addEventListener('click', () => { try { sessionStorage.setItem('lastChar', id); } catch(_){ } });

      const img = document.createElement('img');
      img.className = 'thumb';
      img.alt = item.name || id;
      img.loading = 'lazy';
      // getCharacterImageUrl()은 항상 유효한 URL을 반환 (placeholder 포함)
      img.src = getCharacterImageUrl(item);

      const body = document.createElement('div'); body.className='body';
      const name = document.createElement('div'); name.className='name'; name.textContent = item.name || id;
      const meta = document.createElement('span'); meta.className='meta';
      meta.textContent = (item.shortBio || item.oneLiner || item.greeting || item.summary || '').toString();

      body.appendChild(name); body.appendChild(meta);
      // <!-- .meta 밑에 한 줄 추가 -->
      const chips = document.createElement('div');
      chips.style.marginTop='6px';
      chips.style.display='flex';
      chips.style.gap='6px';
      chips.innerHTML = [item.genre, item.style, item.world].filter(Boolean).map(v=>`<span style="font-size:11px;padding:2px 8px;border:1px solid #334155;border-radius:999px;background:#0b1220;color:#a5b4fc">${v}</span>`).join('');
      body.appendChild(chips);      
      a.appendChild(img); a.appendChild(body);
      return a;
    }
    
    // 세계관 카드 DOM 생성
    function worldCard(item) {
      console.log('[worldCard] Creating card for item:', item);
      const id = item.id || item._id || item.mongo_id || 'world_01';
      const a = document.createElement('a');
      a.className = 'card';
      a.href = `/world.html?world=${id}`;
      a.addEventListener('click', () => { try { sessionStorage.setItem('lastWorld', id); } catch(_){ } });

      const img = document.createElement('img');
      img.className = 'thumb';
      img.alt = item.name || id;
      // 캐릭터 카드처럼 단순하게 resolvePath만 사용
      img.src = resolvePath(item.image || item.image_path || item.cover || '/assets/img/placeholder.jpg');

      const body = document.createElement('div');
      body.className = 'body';
      const name = document.createElement('div');
      name.className = 'name';
      name.textContent = item.name || id;
      const meta = document.createElement('span');
      meta.className = 'meta';
      const summaryText = (item.summary || item.detail || '').toString();
      meta.textContent = summaryText.length > 60 ? summaryText.substring(0, 60) + '...' : summaryText;

      body.appendChild(name);
      body.appendChild(meta);
      
      // 태그 칩 추가
      const chips = document.createElement('div');
      chips.style.marginTop = '6px';
      chips.style.display = 'flex';
      chips.style.gap = '6px';
      chips.style.flexWrap = 'wrap';
      const chipValues = [item.genre, item.style, ...(item.tags || [])].filter(Boolean);
      chips.innerHTML = chipValues.map(v => `<span style="font-size:11px;padding:2px 8px;border:1px solid #334155;border-radius:999px;background:#0b1220;color:#a5b4fc">${v}</span>`).join('');
      body.appendChild(chips);
      
      a.appendChild(img);
      a.appendChild(body);
      console.log('[worldCard] Card created successfully');
      return a;
    }
    
    // 게임 카드 DOM 생성
    function gameCard(item) {
      console.log('[gameCard] Creating card for item:', item);
      const id = item.id || item._id || 'game_01';
      const a = document.createElement('a');
      a.className = 'card';
      a.href = `/game.html?game=${id}`;
      a.addEventListener('click', () => { try { sessionStorage.setItem('lastGame', id); } catch(_){ } });

      const img = document.createElement('img');
      img.className = 'thumb';
      img.alt = item.title || id;
      // 게임 배경 이미지: 백엔드에서 R2 public URL로 변환된 필드 우선 사용
      img.src = item.image || 
                item.background_image_url || 
                (item.world_snapshot && item.world_snapshot.image_url) || 
                '/assets/img/placeholder.jpg';

      const body = document.createElement('div');
      body.className = 'body';
      const name = document.createElement('div');
      name.className = 'name';
      name.textContent = item.title || id;
      const meta = document.createElement('span');
      meta.className = 'meta';
      const summaryText = (item.scenario_summary || item.title || '').toString();
      meta.textContent = summaryText.length > 60 ? summaryText.substring(0, 60) + '...' : summaryText;

      body.appendChild(name);
      body.appendChild(meta);
      
      // 태그 칩 추가
      const chips = document.createElement('div');
      chips.style.marginTop = '6px';
      chips.style.display = 'flex';
      chips.style.gap = '6px';
      chips.style.flexWrap = 'wrap';
      const chipValues = [...(item.tags || [])].filter(Boolean);
      chips.innerHTML = chipValues.map(v => `<span style="font-size:11px;padding:2px 8px;border:1px solid #334155;border-radius:999px;background:#0b1220;color:#a5b4fc">${v}</span>`).join('');
      body.appendChild(chips);
      
      a.appendChild(img);
      a.appendChild(body);
      console.log('[gameCard] Card created successfully');
      return a;
    }

    // 토큰 관리
    const TOKEN_KEY = 'access_token';
    
    function getToken() {
      return localStorage.getItem(TOKEN_KEY);
    }
    
    function isLoggedIn() {
      return !!getToken();
    }

        // 상단 탭 클릭 시 처리 (토스트 또는 로그인 체크)
    function showToast(msg='준비중입니다', ms=1200){
      const el = document.getElementById('toast');
      el.querySelector('.box').textContent = msg;
      el.classList.add('show');
      clearTimeout(showToast.tid);
      showToast.tid = setTimeout(() => el.classList.remove('show'), ms);
    }

    // 현재 선택된 카테고리 (위에서 선언됨)

    // 첫 16개 이미지 preload 함수
    function preloadTopImages(items, count = 16) {
      if (!items || items.length === 0) return;
      
      const preloadedUrls = new Set();
      const topItems = items.slice(0, count);
      
      topItems.forEach(item => {
        const imageUrl = getCharacterImageUrl(item);
        if (!imageUrl || preloadedUrls.has(imageUrl)) return;
        
        preloadedUrls.add(imageUrl);
        
        // <link rel="preload"> 태그 생성
        const link = document.createElement('link');
        link.rel = 'preload';
        link.as = 'image';
        link.href = imageUrl;
        document.head.appendChild(link);
      });
      
      console.log(`[preloadTopImages] Preloaded ${preloadedUrls.size} images`);
    }
    
    // 카드 렌더링 함수 (append 모드 지원)
    function renderCharacterCards(items, { append = false } = {}) {
      const grid = document.getElementById('grid');
      if (!grid) return;
      
      if (!append) {
        grid.innerHTML = '';
      }
      
      items.forEach((it, index) => {
        try {
          let cardElement;
          if (currentCategory === 'characters') {
            cardElement = card(it);
          } else if (currentCategory === 'worlds') {
            cardElement = worldCard(it);
          } else if (currentCategory === 'games') {
            cardElement = gameCard(it);
          }
          if (cardElement) {
            grid.appendChild(cardElement);
          }
        } catch (err) {
          console.error('[renderCharacterCards] Error creating card for item', index, ':', err, it);
        }
      });
    }
    
    // 캐릭터 페이지 fetch 함수 (응답 파싱 확정)
    async function fetchCharactersPage(skip, limit, q = '') {
      try {
        const items = await loadFromApi({ q, skip, limit });
        // 응답 구조가 {items:[]} 인지, []인지, {data:{items:[]}} 인지 확정
        const parsed = Array.isArray(items) ? items
          : Array.isArray(items?.items) ? items.items
          : Array.isArray(items?.data?.items) ? items.data.items
          : [];
        return parsed;
      } catch (error) {
        console.error('[fetchCharactersPage] Error:', error);
        throw error;
      }
    }
    
    // 전체 재렌더 함수 (핵심)
    function renderAllCharacters() {
      const grid = getGridElement();
      if (!grid) {
        console.warn('[home] renderAllCharacters: grid not found');
        return;
      }

      const html = allCharacters.map(renderCard).join('');
      grid.innerHTML = html;
      
      // 클릭 이벤트 재등록 (innerHTML로 인해 이벤트가 사라지므로)
      grid.querySelectorAll('.card').forEach(cardEl => {
        cardEl.addEventListener('click', function() {
          const charId = this.getAttribute('data-character-id');
          if (charId) {
            try { sessionStorage.setItem('lastChar', charId); } catch(_){ }
          }
        });
      });

      console.log('[home] renderAllCharacters', { total: allCharacters.length });
    }
    
    // 초기 로딩 함수 (누적 상태 + 전체 재렌더)
    async function loadInitial() {
      if (initialized || currentCategory !== 'characters') return;
      initialized = true;

      isLoading = true;
      skip = 0;
      allCharacters = [];
      seenIds.clear();

      const grid = getGridElement();
      if (grid) {
        grid.innerHTML = '<div style="opacity:.7;text-align:center;padding:40px;">로딩 중...</div>';
      }

      try {
        const items = await fetchCharactersPage(skip, limit, qApplied);

        // 누적/중복 제거
        for (const it of items) {
          const id = it.id ?? it._id ?? it.pk ?? it.slug ?? JSON.stringify(it);
          if (seenIds.has(id)) continue;
          seenIds.add(id);
          allCharacters.push(it);
        }

        hasMore = items.length === limit;
        renderAllCharacters();

        // preload는 첫 페이지 상위 16개만
        preloadTopImages(allCharacters.slice(0, 16), 16);

        // sentinel 추가
        if (grid && !document.getElementById('home-sentinel')) {
          const sentinel = document.createElement('div');
          sentinel.id = 'home-sentinel';
          sentinel.style.minHeight = '20px';
          grid.appendChild(sentinel);
        }
      } catch (error) {
        console.error('[loadInitial] Failed to load:', error);
        if (grid) {
          grid.innerHTML = '<div style="opacity:.7;text-align:center;padding:40px;color:#ef4444;">로드에 실패했습니다. 잠시 후 다시 시도하세요.</div>';
        }
      } finally {
        isLoading = false;
      }
    }
    
    // 다음 페이지 로드 함수 (누적 상태 + 전체 재렌더)
    async function loadNext() {
      if (!hasMore || isLoading || currentCategory !== 'characters') return;
      
      isLoading = true;
      const nextSkip = skip + limit;
      
      // sentinel에 로딩 표시
      const sentinel = document.getElementById('home-sentinel');
      if (sentinel) {
        sentinel.innerHTML = '<div style="opacity:.7;text-align:center;padding:20px;">로딩 중...</div>';
      }
      
      try {
        const items = await fetchCharactersPage(nextSkip, limit, qApplied);
        
        if (!items.length) {
          hasMore = false;
          if (sentinel) {
            sentinel.innerHTML = '';
          }
          isLoading = false;
          return;
        }

        // 누적/중복 제거
        for (const it of items) {
          const id = it.id ?? it._id ?? it.pk ?? it.slug ?? JSON.stringify(it);
          if (seenIds.has(id)) continue;
          seenIds.add(id);
          allCharacters.push(it);
        }

        skip = nextSkip;
        if (items.length < limit) {
          hasMore = false;
        }

        // append 대신 전체 재렌더
        renderAllCharacters();

        // sentinel 정리
        if (sentinel) {
          sentinel.innerHTML = '';
        }
      } catch (error) {
        console.error('[loadNext] Failed to load next page:', error);
        hasMore = false;
        if (sentinel) {
          sentinel.innerHTML = '<div style="opacity:.7;text-align:center;padding:20px;color:#ef4444;">로드 실패<br/><button id="retry-load" style="margin-top:8px;padding:6px 12px;background:#111827;border:1px solid #1f2937;border-radius:6px;color:#e5e7eb;cursor:pointer;font-size:12px;">다시 시도</button></div>';
          const retryBtn = document.getElementById('retry-load');
          if (retryBtn) {
            retryBtn.addEventListener('click', () => {
              skip = nextSkip - limit;  // 롤백
              hasMore = true;
              loadNext();
            });
          }
        }
      } finally {
        isLoading = false;
      }
    }
    
    // 공통 그리드 렌더링 헬퍼
    async function fetchAndRender(category, q, { append = false } = {}) {
      const grid = document.getElementById('grid');
      if (!grid) return;

      // 캐릭터는 loadInitial 사용 (누적 상태 + 전체 재렌더)
      if (category === 'characters') {
        // 무한 스크롤 상태 초기화
        if (!append) {
          initialized = false;
          allCharacters = [];
          seenIds.clear();
          skip = 0;
          isLoading = false;
          hasMore = true;
        }
        await loadInitial();
        return;
      }

      // worlds, games는 기존 방식 유지
      if (!append) {
        grid.innerHTML = '<div style="opacity:.7;text-align:center;padding:40px;">로딩 중...</div>';
      }

      try {
        let items = [];
        const query = (q || '').trim();

        if (category === 'worlds') {
          items = await loadWorlds(query);
        } else if (category === 'games') {
          items = await loadGames(query);
        }

        console.log('[fetchAndRender] Category:', category, 'q:', query, 'Items:', items.length, 'append:', append);

        if (!append) {
          grid.innerHTML = '';
        }

        if (!items || items.length === 0) {
          if (!append) {
            const label = category === 'characters' ? '캐릭터' : (category === 'worlds' ? '세계관' : '게임');
            const extra = query ? ` 검색어 "${query}" 에 대한 결과가 없습니다.` : ` 표시할 ${label}가 없습니다.`;
            grid.innerHTML = '<div style="opacity:.7;text-align:center;padding:40px;">검색 결과가 없습니다.' +
                             (query ? `<br/><button id="reset-search" style="margin-top:12px;padding:8px 14px;background:#111827;border:1px solid #1f2937;border-radius:999px;color:#e5e7eb;cursor:pointer;font-size:13px;">검색어 초기화</button>` : '') +
                             '</div>';

            const resetBtn = document.getElementById('reset-search');
            if (resetBtn) {
              resetBtn.addEventListener('click', () => {
                clearSearch(true);
              });
            }
          }
          return;
        }

        renderCharacterCards(items, { append });
      } catch (error) {
        console.error('[fetchAndRender] Failed to load items:', error);
        if (!append) {
          grid.innerHTML = '<div style="opacity:.7;text-align:center;padding:40px;color:#ef4444;">검색에 실패했습니다. 잠시 후 다시 시도하세요.</div>';
        }
      }
    }

    // 검색 상태 초기화
    function clearSearch(shouldRefetch = false) {
      qInput = '';
      qApplied = '';
      searchApplied = false;
      
      // 무한 스크롤 상태도 초기화
      if (currentCategory === 'characters') {
        initialized = false;
        allCharacters = [];
        seenIds.clear();
        skip = 0;
        isLoading = false;
        hasMore = true;
      }

      const inputEl = document.getElementById('search-input');
      if (inputEl) inputEl.value = '';

      if (shouldRefetch) {
        fetchAndRender(currentCategory, '');
      }
    }

    function applySearch() {
      const inputEl = document.getElementById('search-input');
      if (!inputEl) return;

      qInput = inputEl.value || '';
      qApplied = (qInput || '').trim();
      searchApplied = qApplied.length > 0;

      // 검색 시 항상 첫 페이지(현재는 offset=0) 기준으로 다시 로드
      fetchAndRender(currentCategory, qApplied);
    }

    // 검색바 이벤트 설정
    function setupSearchBar() {
      const inputEl = document.getElementById('search-input');
      const searchBtn = document.getElementById('search-button');
      const clearBtn = document.getElementById('search-clear');

      if (inputEl) {
        inputEl.addEventListener('input', (e) => {
          qInput = e.target.value;
        });
        inputEl.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            applySearch();
          }
        });
      }

      if (searchBtn) {
        searchBtn.addEventListener('click', () => {
          applySearch();
        });
      }

      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          clearSearch(true);
        });
      }
    }

        // 카테고리 탭 클릭 핸들러
    function setupCategoryTabs() {
      document.querySelectorAll('.category-tab').forEach(tab => {
        tab.addEventListener('click', async function() {
          const category = this.getAttribute('data-category');
          if (category === currentCategory) return;
          
          // 기존 observer 정리
          if (window.homeScrollObserver) {
            window.homeScrollObserver.disconnect();
            window.homeScrollObserver = null;
          }
          
          // 탭 활성화 상태 변경
          document.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
          this.classList.add('active');
          
          currentCategory = category;
          
          // 무한 스크롤 상태 초기화
          skip = 0;
          isLoading = false;
          hasMore = true;
          isFirstLoad = true;
          
          // 제목 변경
          const h1 = document.querySelector('h1');
          if (category === 'characters') {
            h1.textContent = '캐릭터 선택';
          } else if (category === 'worlds') {
            h1.textContent = '세계관 선택';
          } else if (category === 'games') {
            h1.textContent = '게임 선택';
          }
          
          // 탭 전환 시:
          // - 이미 검색이 적용된 상태면 같은 qApplied 로 해당 탭을 즉시 검색
          // - 아직 searchApplied=false 라면 기본 리스트만 로드
          const query = searchApplied ? qApplied : '';
          await fetchAndRender(currentCategory, query);
          
          // characters 탭일 때만 observer 재설정
          if (category === 'characters') {
            // 무한 스크롤 상태 초기화 (누적 상태 방식)
            initialized = false;
            allCharacters = [];
            seenIds.clear();
            skip = 0;
            isLoading = false;
            hasMore = true;
            
            setTimeout(() => {
              // setupInfiniteScroll이 반드시 정의된 다음 호출되게 가드 추가
              if (typeof setupInfiniteScroll === 'function') {
                setupInfiniteScroll();
              } else {
                console.warn('[home] setupInfiniteScroll not defined, infinite scroll disabled');
              }
            }, 100);
          }
        });
      });
    }

        // 초기화: 네비게이션 바 핸들러+캐릭터 목록 렌더링
    (async function init(){
      // nav buttons -> 처리
            // 상단 네비게이션 탭 클릭 시 처리
      document.querySelectorAll('.tab').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const navType = btn.getAttribute('data-nav');

          if (navType === 'search') {
            // Search 메뉴는 search.html 로 단순 이동 (로그인 무관)
            return;
          }
          
          if (navType === 'my') {
            e.preventDefault();
            window.location.href = '/my.html';
            return;
          }
          
          if (navType === 'create') {
            e.preventDefault();
            window.location.href = '/create/index.html';
            return;
          }
          
          // 나머지 메뉴는 로그인 체크 (기존 정책 유지)
          if (!isLoggedIn()) {
            e.preventDefault();
            showToast('로그인이 필요합니다.', 2000);
            return;
          }
          
          e.preventDefault();
          showToast('준비중입니다.', 1500);
        });
      });

      // 검색바 + 카테고리 탭 설정
      setupSearchBar();
      setupCategoryTabs();

      const grid = document.getElementById('grid');

      // 초기 상태: 검색어 없이 캐릭터 기본 리스트
      await fetchAndRender(currentCategory, '');
      
      // 무한 스크롤: IntersectionObserver 설정 (characters 전용)
      if (currentCategory === 'characters') {
        setTimeout(() => {
          // setupInfiniteScroll이 반드시 정의된 다음 호출되게 가드 추가
          if (typeof setupInfiniteScroll === 'function') {
            setupInfiniteScroll();
          } else {
            console.warn('[home] setupInfiniteScroll not defined, infinite scroll disabled');
          }
        }, 100);
      }
     })();
   </script>
  <div id="gallery" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:12px;"></div>
<script>
(async () => {
  try {
    /* === API BASE URL 자동 감지 수정 === */

    const isLocal =
      typeof window !== 'undefined' &&
      (window.location.hostname === 'localhost' ||
       window.location.hostname === '127.0.0.1');

    console.log('[API BASE URL]:', API_BASE_URL);
    const url = `${API_BASE_URL}/assets/images?prefix=char/&limit=60&signed=true`;

    const res = await fetch(url, { credentials: 'include' });
    const data = await res.json();

    const $g = document.getElementById('gallery') || (() => {
      const div = document.createElement('div');
      div.id = 'gallery';
      div.style.display = 'grid';
      div.style.gridTemplateColumns = 'repeat(auto-fill,minmax(140px,1fr))';
      div.style.gap = '12px';
      document.body.appendChild(div);
      return div;
    })();

    $g.innerHTML = '';
    (data.items || []).forEach(item => {
      const img = document.createElement('img');
      img.src = item.url;
      img.alt = item.key || '';
      img.loading = 'lazy';
      img.style.width = '100%';
      img.style.height = '200px';
      img.style.objectFit = 'cover';
      img.referrerPolicy = 'no-referrer';
      img.crossOrigin = 'anonymous';
      $g.appendChild(img);
    });
  } catch (e) {
    console.error('Failed to load images', e);
  }
})();
</script>
 </body>
 </html>
