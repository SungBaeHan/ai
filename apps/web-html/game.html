<!-- ========================================
     apps/web-html/game.html — 게임 상세(채팅) 화면
     - URL ?game=1 또는 ?game_id=1 지원
     - /v1/games/:id 단건 호출해서 렌더
     - 이미지 경로 보정(resolvePath)로 /assets/game/… 보장
     - 게임 채팅 시작
     ======================================== -->
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Game Chat • TRPG</title>
  <script src="/js/config.js"></script>
  <script src="/js/assets.js"></script>
  <script>
    // 전역 API 엔드포인트 설정 (어디서든 window.API_BASE_URL로 접근)
    window.API_BASE_URL = 'https://api.arcanaverse.ai';
    window.API_BASE = 'https://api.arcanaverse.ai';
    
    // 게임 ID 주입 (쿼리 파라미터에서 추출)
    (function() {
      const params = new URLSearchParams(window.location.search);
      const gameId = params.get('game') || params.get('game_id');
      if (gameId) {
        // 'game_1' 형식이면 숫자만 추출
        const match = gameId.match(/^game_(\d+)$/i);
        window.GAME_ID = match ? parseInt(match[1], 10) : parseInt(gameId, 10);
      }
    })();
  </script>
  <script src="/js/game_turn.js"></script>
  <style>
    :root { 
      color-scheme: dark; /* 다크 테마 힌트 */
      --hud-width: 900px; /* 상단 HUD(.game-hero-card) 폭과 동일 */
    }
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden; /* 전체 페이지 스크롤 방지 */
    }
    body { 
      background:#0b0f14; 
      color:#e5e7eb; 
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,'Apple SD Gothic Neo','Malgun Gothic',sans-serif; 
    }
    /* 페이지 전체를 100vh로 고정 */
    .game-body {
      height: 100vh;
    }
    /* 루트 컨테이너: 위/가운데/아래 세로 플렉스 */
    .game-root {
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    /* 상단 HUD + 소개 영역: 내용 높이에 맞게, 스크롤 X */
    .game-top {
      flex: 0 0 auto;
    }
    /* 가운데 채팅 영역: 남는 공간 다 차지 + 여기만 스크롤 */
    .game-middle {
      flex: 1 1 auto;
      min-height: 0;          /* 중요: 자식이 overflow 할 수 있게 */
      display: flex;
      flex-direction: column;
    }
    .topbar-wrap { display:flex; justify-content:center; border-bottom:1px solid #1b2430; background:#0e141c; position:sticky; top:0; z-index:20; }
    .topbar { width:100%; max-width:980px; display:flex; align-items:center; gap:10px; padding:10px 14px; justify-content:space-between; }
    .topbar-left { display:flex; align-items:center; gap:10px; flex:1; }
    .topbar-right { display:flex; align-items:center; gap:10px; }
    .back { display:inline-flex; align-items:center; justify-content:center; width:36px; height:36px; border-radius:10px; border:1px solid #223042; background:#0f172a; color:#cbd5e1; cursor:pointer; }
    .title { font-weight:700; font-size:15px; color:#f1f5f9; }
    .persona-btn { padding:6px 12px; border-radius:8px; border:1px solid #334155; background:#1f2937; color:#e5e7eb; font-size:13px; cursor:pointer; transition:all .15s ease; }
    .persona-btn:hover { background:#334155; border-color:#475569; }
    .header-persona-badge { display:flex; align-items:center; gap:8px; padding:4px 8px; border-radius:8px; border:1px solid #334155; background:#1f2937; cursor:pointer; transition:all .15s ease; }
    .header-persona-badge:hover { background:#334155; border-color:#475569; }
    .header-persona-avatar { width:24px; height:24px; border-radius:50%; object-fit:cover; box-shadow:0 0 4px rgba(0,0,0,.3); }
    .header-persona-name { font-size:13px; color:#e5e7eb; }
    .hero { position:relative; margin:18px auto; max-width:980px; }
    .hero img { width:100%; border-radius:14px; border:1px solid #1f2937; box-shadow:0 10px 28px rgba(0,0,0,.35); display:block; }
    .panel { max-width:980px; margin:10px auto 18px; background:#0f172a; border:1px solid #1e293b; border-radius:12px; padding:12px 14px; }
    .chips { margin-top:6px; display:flex; gap:8px; flex-wrap:wrap; }
    .chip { padding:3px 8px; font-size:11px; border-radius:999px; border:1px solid #334155; color:#a5b4fc; background:#0b1220; }
    .hint { font-size:12px; color:#9ca3af; margin-top:6px; }
    /* game-hud-box는 game-hero-stats로 대체되었으므로 제거 */
    /* 기존 스타일은 game-hero-stats에 통합됨 */
    .game-hud-section {
      min-width:180px;
    }
    .game-hud-title {
      font-weight:600;
      margin-bottom:4px;
      opacity:0.7;
    }
    .game-hud-char {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-top:4px;
      font-size:12px;
    }
    .game-hud-char-name {
      font-weight:600;
      margin-right:8px;
    }
    .game-hud-char-stats {
      display:flex;
      gap:8px;
      opacity:0.85;
    }
    /* 전체 게임 페이지: 상단 고정 + 하단 스크롤을 위한 기본 레이아웃 */
    .game-page {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 60px); /* topbar 높이 제외 (약 60px) */
      overflow: hidden;       /* 페이지 레벨 스크롤 방지 */
    }
    /* game-body가 추가된 경우 높이 조정 */
    .game-page.game-body {
      height: calc(100vh - 60px);
    }
    /* 전체 게임 레이아웃: 배경 위에서 중앙 정렬 */
    .game-layout {
      width: 100%;
      display: flex;
      justify-content: center;
    }
    /* ✅ HUD / 소개 / 채팅이 모두 들어가는 중앙 컬럼 */
    /* game-root 역할도 함께 수행 */
    .game-main-column {
      /* 상단 HUD 카드 폭과 맞춰줄 값 (기존 HUD width 에 맞춰 수정 가능) */
      max-width: 960px;
      width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      height: 100%;  /* game-root 역할 */
    }
    /* 상단 스탯 카드와 소개/채팅이 공유할 가로 폭 래퍼 */
    .game-inner-width {
      max-width: 960px;      /* 상단 카드 실제 폭에 맞게 조절해도 됨 */
      width: 100%;
      margin: 0 auto;        /* 가운데 정렬 */
      box-sizing: border-box;
    }
    /* HUD 와 소개는 이 컬럼 안에서 전체 폭 사용 */
    .game-top-panel {
      width: 100%;
    }
    /* 상단 히어로 영역: 높이 제한하여 압축 */
    .game-hero {
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-height: 25vh;    /* 화면의 25%까지만 사용 (더 압축) */
      min-height: 150px;   /* 최소값 더 줄임 */
      z-index: 10;
      margin-bottom: 0;
      overflow: hidden;
      width: 100%;  /* game-main-column 안에서 전체 폭 사용 */
    }
    /* 이미지 카드 전체 */
    .game-hero-card {
      position: relative;
      width: 100%;
      max-width: 100%;  /* game-main-column 폭에 맞춤 */
      margin: 0 auto;
      border-radius: 16px;
      overflow: hidden;
    }
    /* 이미지 */
    .game-hero-image {
      width: 100%;
      display: block;
      border-radius: 16px;
    }
    /* 소개 패널 (이미지+스탯 아래 배치) - HUD 폭과 정확히 맞도록 */
    .game-intro-panel {
      flex-shrink: 0;
      max-height: 110px;  /* 2줄 정도 더 표시 가능하도록 높이 증가 */
      overflow-y: auto;  /* 내용이 넘칠 경우 스크롤 가능 */
      box-sizing: border-box;
      margin: 8px auto 0;  /* 가운데 정렬, 상단 여백 */
      background: #0f172a;
      border: 1px solid #1e293b;
      border-radius: 12px;
      padding: 6px 0;  /* 좌우 패딩 제거하여 노란색 영역에 닿도록 */
      font-size: 0.85rem;  /* 폰트 크기 조정 */
      scrollbar-width: none;  /* Firefox: 스크롤바 숨김 */
      -ms-overflow-style: none;  /* IE/Edge: 스크롤바 숨김 */
    }
    /* 소개 패널 내부 콘텐츠에만 좌우 패딩 적용 */
    .game-intro-panel > div {
      padding-left: 14px;
      padding-right: 14px;
    }
    .game-intro-panel::-webkit-scrollbar {
      display: none;  /* Chrome/Safari: 스크롤바 숨김 */
    }
    /* ⭐ 스탯 HUD 오버레이 */
    .game-hero-stats {
      position: absolute;
      bottom: 12px;                 /* 이미지 안에서의 아래쪽 위치 */
      left: 12px;
      right: 12px;                  /* 좌우 여백이 exactly 이미지 카드 폭에 맞도록 */
      padding: 14px 18px;
      border-radius: 12px;
      background: rgba(10, 12, 20, 0.80);  /* 반투명 HUD */
      backdrop-filter: blur(6px);
      color: #fff;
      z-index: 10;                  /* 이미지보다 위 */
      display: flex;
      gap: 24px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      font-size: 0.9rem;
    }
    /* 텍스트 너무 붙지 않도록 */
    .game-hero-stats table,
    .game-hero-stats div {
      width: 100%;
    }
    /* 채팅 영역 자체는 중앙 컬럼 안에서만 동작 */
    /* 가운데 채팅 로그만 스크롤 */
    .game-chat-log {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      padding: 12px 24px 16px;
      /* 스크롤바만 숨기기 (스크롤 기능은 유지) */
      scrollbar-width: none;  /* Firefox: 스크롤바 숨김 */
      -ms-overflow-style: none;  /* IE/Edge: 스크롤바 숨김 */
    }
    /* 채팅 로그 본문은 전체 폭 사용 */
    #chat, #chat-log, #game-log-messages {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    /* 메시지 행 스타일 */
    .msg { display:flex; align-items:flex-end; gap:8px; margin:8px 0; }
    .msg.me { justify-content:flex-end; }
    .bubble { background:#111827; border:1px solid #1f2937; padding:10px 14px; border-radius:14px; white-space:pre-wrap; line-height:1.6; max-width:70%; }
    .me .bubble { background:rgba(63,131,248,0.25); border-color:#334155; }
    .user-persona-badge { display:flex; align-items:center; gap:8px; }
    .user-persona-avatar { width:28px; height:28px; border-radius:50%; object-fit:cover; box-shadow:0 0 4px rgba(0,0,0,.3); }
    .user-persona-name { font-size:12px; color:#cbd5e1; opacity:0.85; }
    .game-chat-log::-webkit-scrollbar {
      display: none;  /* Chrome/Safari: 스크롤바 숨김 */
    }
    /* 하단 입력창: 고정 */
    .game-bottom {
      flex: 0 0 auto;
    }
    /* 입력창은 flex 하단에 고정 */
    /* 중앙 컬럼 안에서 전체 폭 사용 */
    .game-chat-input {
      flex-shrink: 0;
      width: 100%;
      padding: 8px 16px 12px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(2px);
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      /* position: fixed/absolute/bottom 제거 확인 - flex만 사용 */
    }
    /* 채팅 로그 영역 안에 자연스럽게 배치될 선택지 버튼 컨테이너 */
    /* 부모 컨테이너 기준으로 중앙 정렬 */
    .game-turn-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 16px 0 8px;
      width: 100%;
      justify-content: center;
      align-items: center;
      padding: 0;
    }
    /* 버튼이 위로 딸려가지 않도록 position 관련 스타일은 절대 넣지 말 것 */
    .game-turn-actions button {
      /* 기존 버튼 스타일 유지 */
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid #334155;
      background: #111827;
      color: #c7d2fe;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    .game-turn-actions button:hover {
      background: #1f2937;
      border-color: #475569;
    }
    .game-turn-actions button:active {
      transform: translateY(1px);
    }
    /* 한 줄 레이아웃 공통 */
    .chat-row {
      display: flex;
      margin: 4px 0;
      animation: fadeInUp .35s ease;
    }
    /* 말풍선 공통 스타일 */
    .chat-bubble {
      max-width: 70%;      /* 너무 넓어지지 않게 */
      padding: 8px 12px;
      border-radius: 16px;
      box-sizing: border-box;
      white-space: pre-wrap;
      line-height: 1.6;
    }
    /* ✅ NPC: 왼쪽 정렬 (노란 박스 왼쪽에 붙게) */
    .chat-row.chat-npc {
      justify-content: flex-start;   /* 왼쪽 정렬 */
    }
    .chat-row.chat-npc .chat-bubble {
      background: #111827;
      border: 1px solid #1f2937;
      color: #e5e7eb;
      margin-left: 8px;              /* 아바타와 간격 */
      margin-right: auto;            /* 오른쪽은 자동 */
    }
    /* ✅ 플레이어: 오른쪽 정렬 (노란 박스 오른쪽에 붙게) */
    .chat-row.chat-player {
      justify-content: flex-end;     /* 오른쪽 정렬 */
    }
    .chat-row.chat-player .chat-bubble {
      background: rgba(63,131,248,0.25);
      border: 1px solid #334155;
      color: #e5e7eb;
      margin-left: auto;             /* 왼쪽은 자동 */
      margin-right: 0;
    }
    /* 말풍선 공통 - 기존 .msg 클래스 호환성 유지 */
    .msg { 
      display: flex; 
      align-items: flex-start; 
      gap: 10px; 
      margin: 4px 0; 
      padding: 0;
      animation: fadeInUp .35s ease; 
      max-width: 100%;
    }
    /* NPC: 왼쪽 정렬 (노란 박스 왼쪽에 붙게) */
    .msg:not(.me) {
      justify-content: flex-start;
    }
    /* 플레이어: 오른쪽 정렬 (노란 박스 오른쪽에 붙게) */
    .msg.me { 
      flex-direction: row-reverse; 
      margin-left: auto;           /* 자동으로 오른쪽으로 밀기 */
      justify-content: flex-end;
      align-items: flex-end;
    }
    .avatar { width:42px; height:42px; border-radius:50%; object-fit:cover; box-shadow:0 0 6px rgba(0,0,0,.4); }
    .bubble { background:#111827; border:1px solid #1f2937; padding:10px 14px; border-radius:14px; white-space:pre-wrap; line-height:1.6; max-width:70%; }
    .me .bubble { background:rgba(63,131,248,0.25); border-color:#334155; }
    /* chat-row 구조에서 아바타 스타일 */
    .chat-row .avatar {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      object-fit: cover;
      box-shadow: 0 0 6px rgba(0,0,0,.4);
      flex-shrink: 0;
    }
    .inputBar { 
      /* position:fixed 제거 - flex layout으로 처리 */
      border-top:1px solid #1b2430; 
      background:#0e141c; 
      padding:12px; 
    }
    .inputIn { width: 100%; display:flex; gap:8px; }
    textarea { flex:1; resize:none; background:#0b1220; border:1px solid #1f2937; border-radius:10px; color:#e5e7eb; padding:10px 12px; min-height:44px; }
    button { padding:0 14px; border-radius:10px; border:1px solid #334155; background:#111827; color:#c7d2fe; height:44px; }
    button[disabled]{ opacity:.6; cursor:not-allowed; }
    .bg { position:fixed; inset:0; background-position:center; background-size:cover; opacity:.4; filter:blur(1.5px) brightness(0.9); z-index:-1; transition:filter .5s ease, opacity .5s ease; }
    .debug { max-width:980px; margin:6px auto 0; font-size:12px; color:#93c5fd; opacity:.9; white-space:pre-wrap; }
    /* toast layer */
    .toast { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; opacity:0; transition:opacity .18s ease; z-index:50; }
    .toast.show { opacity:1; }
    .toast .box { pointer-events:auto; min-width:200px; max-width:80vw; background:#0f172a; border:1px solid #1f2937; color:#e5e7eb; padding:14px 18px; border-radius:12px; box-shadow:0 12px 32px rgba(0,0,0,.45); text-align:center; }
    @keyframes fadeInUp { from { opacity:0; transform:translateY(12px); } to { opacity:1; transform:translateY(0); } }
    
    /* persona modal */
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,.75); display:flex; align-items:center; justify-content:center; z-index:100; opacity:0; pointer-events:none; transition:opacity .2s ease; }
    .modal-backdrop.show { opacity:1; pointer-events:auto; }
    .modal-backdrop.force-open { pointer-events:auto; } /* 강제 모달 (닫기 불가) */
    .modal { background:#111827; border:1px solid #1f2937; border-radius:12px; width:90%; max-width:500px; max-height:90vh; display:flex; flex-direction:column; box-shadow:0 20px 60px rgba(0,0,0,.5); }
    .modal-header { display:flex; justify-content:space-between; align-items:center; padding:20px; border-bottom:1px solid #1f2937; }
    .modal-header h2 { margin:0; font-size:18px; color:#f3f4f6; }
    .modal-close { background:none; border:none; color:#94a3b8; font-size:24px; cursor:pointer; padding:0; width:32px; height:32px; display:flex; align-items:center; justify-content:center; }
    .modal-close:hover { color:#e5e7eb; }
    .modal-close.hidden { display:none; } /* 강제 모달에서 닫기 버튼 숨김 */
    .modal-body { padding:20px; max-height:60vh; overflow-y:auto; }
    
    /* Persona Card Styles */
    .persona-list { display:flex; flex-direction:column; gap:12px; }
    .persona-card { background:#111827; border:1px solid #1f2937; border-radius:12px; padding:16px; transition:all .15s ease; cursor:pointer; }
    .persona-card:hover { border-color:#3b82f6; }
    .persona-card.selected { border-color:#3b82f6; border-width:2px; background:#1e3a8a; }
    .persona-card.default { border-color:#3b82f6; background:#1e3a8a; }
    .persona-card-header { display:flex; align-items:center; gap:12px; margin-bottom:12px; }
    .persona-avatar { width:64px; height:64px; border-radius:8px; background:#1f2937; object-fit:cover; border:2px solid #334155; }
    .persona-info { flex:1; }
    .persona-name { font-size:16px; font-weight:600; color:#f3f4f6; margin-bottom:4px; }
    .persona-badge { display:inline-block; padding:2px 8px; background:#3b82f6; color:#fff; border-radius:4px; font-size:11px; font-weight:600; margin-right:6px; }
    .persona-gender { font-size:12px; color:#94a3b8; }
    .persona-bio { font-size:13px; color:#cbd5e1; line-height:1.5; margin-bottom:12px; max-height:60px; overflow:hidden; text-overflow:ellipsis; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; }
    .persona-selected-info { padding:12px; background:#1e293b; border-radius:8px; margin-top:12px; font-size:13px; color:#cbd5e1; }
    .persona-selected-info strong { color:#3b82f6; }
    .modal-footer { padding:20px; border-top:1px solid #1f2937; flex-shrink:0; }
    .btn-modal { padding:10px 20px; border-radius:6px; border:1px solid #334155; background:#1f2937; color:#e5e7eb; font-size:14px; font-weight:500; cursor:pointer; transition:all .15s ease; }
    .btn-modal:hover { background:#334155; }
    .btn-modal.primary { background:#3b82f6; border-color:#2563eb; color:#fff; }
    .btn-modal.primary:hover { background:#2563eb; }
    .modal-loading { text-align:center; padding:40px; color:#94a3b8; }
    
    /* Confirm Dialog */
    .confirm-dialog { position:fixed; inset:0; background:rgba(0,0,0,.75); display:flex; align-items:center; justify-content:center; z-index:110; opacity:0; pointer-events:none; transition:opacity .2s ease; }
    .confirm-dialog.show { opacity:1; pointer-events:auto; }
    .confirm-dialog-box { background:#111827; border:1px solid #1f2937; border-radius:12px; width:90%; max-width:400px; padding:24px; box-shadow:0 20px 60px rgba(0,0,0,.5); }
    .confirm-dialog-title { font-size:18px; font-weight:600; color:#f3f4f6; margin-bottom:16px; }
    .confirm-dialog-message { font-size:14px; color:#cbd5e1; margin-bottom:24px; line-height:1.5; }
    .confirm-dialog-actions { display:flex; gap:12px; justify-content:flex-end; }
    
    /* ===== Game Chat Message System (UX v1) ===== */
    .game-msg {
      display: flex;
      margin: 10px 0;
    }
    .game-bubble {
      position: relative;
      max-width: 62%;
      padding: 10px 12px;
      border-radius: 12px;
      line-height: 1.35;
      font-size: 13px;
    }
    /* Alignment (role 기반, action은 modifier로 정렬 영향 없음) */
    .game-msg--player { justify-content: flex-end; }
    .game-msg--npc,
    .game-msg--narrator { justify-content: flex-start; }
    /* Color/tones (no hard-coded brand colors, use existing theme vars if any) */
    .game-msg--player .game-bubble { background: rgba(80, 120, 255, 0.22); }
    .game-msg--npc .game-bubble { background: rgba(255, 255, 255, 0.14); }
    .game-msg--narrator .game-bubble {
      background: rgba(255, 255, 255, 0.08);
      font-style: italic;
    }
    /* action style as modifier (do not override alignment) */
    .game-msg--action .game-bubble {
      background: rgba(255, 200, 80, 0.14);
      border: 1px solid rgba(255, 200, 80, 0.25);
    }
    /* Action head */
    .game-action-head {
      font-size: 11px;
      letter-spacing: 0.08em;
      opacity: 0.8;
      margin-bottom: 6px;
    }
    /* NPC avatar next to bubble (캐릭터/세계관 채팅 수준 크기) */
    .game-avatar {
      width: 38px;
      height: 38px;
      border-radius: 999px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      margin-right: 10px;
      align-self: flex-end;
      border: 1px solid rgba(255,255,255,0.25);
      background-color: rgba(0,0,0,0.25);
      flex: 0 0 auto;
    }
    .game-avatar--fallback {
      display: grid;
      place-items: center;
      font-size: 13px;
      color: rgba(255,255,255,0.9);
    }
    /* Mini persona badge: stamp style (가시성 개선) */
    .persona-badge--mini {
      position: absolute;
      right: 6px;
      bottom: 6px;
      width: 22px;
      height: 22px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      overflow: hidden;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.25);
      font-size: 10px;
      user-select: none;
      pointer-events: auto;
      z-index: 2;
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
    }
    .persona-badge--mini img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    /* Small tags */
    .game-npc-tag,
    .game-narrator-tag {
      position: absolute;
      left: 8px;
      top: -8px;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(255,255,255,0.15);
      opacity: 0.85;
    }
    .game-narrator-tag { opacity: 0.6; }
  </style>
</head>
<body>
  <div class="bg" id="bg"></div> <!-- 흐림 배경 -->

  <div class="topbar-wrap">
    <div class="topbar">
      <div class="topbar-left">
        <button id="backBtn" class="back" title="뒤로 가기">←</button> <!-- 뒤로가기 -->
        <div class="title" id="title">로딩 중…</div>                   <!-- 게임 이름 -->
      </div>
      <div class="topbar-right">
        <div id="headerPersonaBadge" class="header-persona-badge" style="display:none;" title="페르조나 설정" onclick="openPersonaModal()">
          <img id="headerPersonaAvatar" class="header-persona-avatar" src="" alt="" />
          <span id="headerPersonaName" class="header-persona-name"></span>
        </div>
        <button id="personaBtn" class="persona-btn" title="페르조나 설정" style="display:none;">Persona</button> <!-- 페르조나 버튼 (fallback) -->
      </div>
    </div>
  </div>

  <div id="game-page" class="game-page game-layout game-body">
    <!-- ✅ 메인 컬럼 래퍼: HUD / 소개 / 채팅을 모두 감싸는 컨테이너 -->
    <div class="game-main-column game-root">
      <!-- 상단: HUD + 소개 영역 (고정) -->
      <div class="game-top">
        <!-- 상단: 이미지 + 시나리오 + HUD(스탯) -->
        <section class="game-hero game-top-panel">
          <div class="game-hero-card top-hud game-inner-width">
            <img id="hero" class="game-hero-image" alt="cover" src="/assets/img/placeholder.jpg" /> <!-- 히어로 이미지 -->
            <div class="debug" id="dbg"></div> <!-- 디버그 로그(요청/이미지 경로) -->

            <!-- ⭐ HUD 스탯 패널 (이미지 위에 오버레이) -->
            <div id="game-hud" class="game-hero-stats">
              <div class="game-hud-section">
                <div class="game-hud-title">상태</div>
                <div class="game-hud-body">게임을 시작하면 상태가 표시됩니다.</div>
              </div>
            </div>
          </div>
        </section>

        <!-- 소개 박스 -->
        <div id="game-intro" class="game-intro-panel game-inner-width">
          <div id="game-intro-title" style="font-weight:700; margin-bottom:6px;">소개</div>
          <div id="game-narration" style="opacity:.9"></div> <!-- 내레이션 영역 -->
          <div class="chips">
            <span class="chip">TRPG</span>
            <span class="chip" id="chip-name">게임</span>
          </div>
          <div class="hint">Tip: 메세지를 보내면 게임 턴이 진행됩니다.</div>
        </div>
      </div> <!-- /game-top -->

      <!-- 가운데: 채팅 로그만 스크롤 되는 영역 -->
      <div class="game-middle">
        <section id="chat-log" class="game-chat-log game-inner-width">
          <div id="game-log-messages">
            <div class="chat" id="chat"></div> <!-- 채팅 로그 -->
            <div class="chat" id="chat-log-old" style="display:none;"></div> <!-- 턴 시스템용 채팅 로그 -->
          </div>
          <!-- ⭐ 선택지 버튼은 여기 -->
          <div id="game-turn-actions" class="game-turn-actions">
            <!-- JS가 여기 안에 버튼들을 append 하도록 유지 -->
          </div>
          <!-- 스크롤 하단 마커 (자동 스크롤용) -->
          <div id="chat-bottom-marker" style="height: 1px;"></div>
        </section>
      </div> <!-- /game-middle -->

      <!-- 하단: 입력창 고정 -->
      <div class="game-bottom">
        <div class="game-chat-input" id="chat-input">
          <div class="inputIn">
            <textarea id="ta" placeholder="메시지 입력…"></textarea>  <!-- 입력창 (기존) -->
            <textarea id="user-input" placeholder="메시지 입력…" style="display:none;"></textarea>  <!-- 턴 시스템용 입력창 -->
            <button id="send">보내기</button>                         <!-- 전송 (기존) -->
            <button id="send-btn" style="display:none;">보내기</button>  <!-- 턴 시스템용 전송 버튼 -->
          </div>
        </div>
      </div> <!-- /game-bottom -->
    </div> <!-- /game-main-column /game-root -->
  </div>

  <!-- Toast Layer -->
  <div id="toast" class="toast" aria-live="polite" aria-atomic="true">
    <div class="box">준비중입니다</div>
  </div>

  <!-- Persona Modal -->
  <div id="personaModal" class="modal-backdrop">
    <div class="modal">
      <div class="modal-header">
        <h2>페르조나 선택</h2>
        <button class="modal-close" id="personaModalClose" onclick="closePersonaModal()">×</button>
      </div>
      <div class="modal-body" id="personaModalBody">
        <div class="modal-loading">로딩 중...</div>
      </div>
      <div class="modal-footer">
        <div id="personaSelectedInfo" class="persona-selected-info" style="display:none;"></div>
        <div style="display:flex; justify-content:flex-end; gap:12px; width:100%;">
          <button class="btn-modal" id="personaCancelBtn" onclick="closePersonaModal()" style="display:none;">취소</button>
          <button class="btn-modal primary" id="personaConfirmBtn" onclick="confirmPersonaSelection()" disabled>완료</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Confirm Dialog (전투 중 변경 확인) -->
  <div id="confirmDialog" class="confirm-dialog">
    <div class="confirm-dialog-box">
      <div class="confirm-dialog-title">페르조나 변경 확인</div>
      <div class="confirm-dialog-message" id="confirmDialogMessage">게임 중에 페르조나를 변경하면 이후 대사와 전투 판정에 즉시 영향을 줍니다. 정말 변경하시겠습니까?</div>
      <div class="confirm-dialog-actions">
        <button class="btn-modal" onclick="closeConfirmDialog(false)">아니오</button>
        <button class="btn-modal primary" onclick="closeConfirmDialog(true)">예</button>
      </div>
    </div>
  </div>

  <script>
    // API_BASE_URL은 이미 위쪽에서 window.API_BASE_URL로 설정됨

    // --- 전역/유틸 -------------------------------------------------------------
    let CURRENT_GAME = null;  // 현재 게임
    let PERSONAS_LIST = [];  // 페르조나 목록
    let SELECTED_PERSONA_ID = null;  // 선택된 페르조나 ID
    let isPersonaModalForceOpen = false;  // 강제 모달 여부
    let pendingPersonaSelection = null;  // 전투 중 확인 대기 중인 persona 선택
    const FALLBACK_SVG = 'data:image/svg+xml;utf8,' + encodeURIComponent(
      `<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="675"><rect width="100%" height="100%" fill="#0e141c"/><text x="50%" y="50%" fill="#94a3b8" font-size="48" font-family="sans-serif" text-anchor="middle" dominant-baseline="middle">No Image</text></svg>`
    );
    const dbg = (m) => { 
      const el=document.getElementById('dbg'); 
      // el.textContent = (el.textContent?el.textContent+"\n":"") + m; 
      // console.log(m); 
    };

    function qs(k){ return new URL(location.href).searchParams.get(k); } // 쿼리 파서

    // 'game_1' → 1 / '1' → 1
    function normalizeGameId(v){
      if(!v) return null;
      if(/^game_\d{1,6}$/i.test(v)) return parseInt(v.split('_')[1],10);
      if(/^\d+$/.test(v)) return parseInt(v,10);
      return v;
    }

    // 이미지 경로 보정 → 상대 경로를 풀 URL로 변환
    // R2 Public URL (배경 이미지와 동일한 방식)
    const R2_PUBLIC_URL = "https://pub-09b0f3cad63f4891868948d43f19febf.r2.dev";
    const ASSET_BASE_URL = window.location.origin; // => https://www.arcanaverse.ai
    
    function resolveAssetUrl(path) {
      if (!path) return "";
      // 이미 풀 URL이면 그대로 반환 (R2 URL 포함)
      if (path.startsWith("http://") || path.startsWith("https://")) return path;
      
      // 상대 경로(/assets/...)를 R2 Public URL로 변환 (배경 이미지와 동일)
      // 배경 이미지처럼 R2_PUBLIC_URL을 직접 사용
      if (path.startsWith("/")) {
        return `${R2_PUBLIC_URL}${path}`;
      }
      // 상대 경로가 /로 시작하지 않으면 /assets/char/ 또는 /assets/img/ 경로로 가정
      if (path.includes('/char/') || path.includes('char_')) {
        return `${R2_PUBLIC_URL}/assets/char/${path.replace(/^.*\/(char\/|char_)/, '').replace(/^.*\//, '')}`;
      }
      return `${R2_PUBLIC_URL}/assets/img/${path}`;
    }
    
    function resolvePath(p){
      if (!p) {
        return resolveAssetUrl('/assets/img/placeholder.jpg');
      }
      // 이미 풀 URL이면 그대로 반환
      if (/^https?:\/\//i.test(p)) return p;
      
      p = String(p).replace(/\\/g, '/').trim();
      
      // resolveAssetUrl 사용 (unreachable code 제거)
      return resolveAssetUrl(p);
    }

    // 안전한 hero 이미지 로더(404 시 SVG로 대체)
    function safeSetHero(imgUrl){
      const hero=document.getElementById('hero');
      hero.onerror=()=>{ dbg('[hero 404] '+imgUrl); hero.src=FALLBACK_SVG; };
      hero.onload =()=>{ dbg('[hero 200] '+imgUrl); };
      hero.src=imgUrl||'/assets/img/placeholder.jpg';
      dbg('[hero set] '+hero.src);
    }

    // 단일 게임 API 호출 (상세)
    async function fetchGame(id){
      dbg('[fetch] /v1/games/'+id);
      const r = await fetch(`${API_BASE_URL}/v1/games/${id}`, {
        method: "GET",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        cache: 'no-store'
      });
      dbg('[fetch status] '+r.status);
      if(!r.ok) throw new Error('게임 불러오기 실패: HTTP '+r.status);
      const j = await r.json();
      dbg('[fetch image] '+j.background_image_path);
      return j;
    }

    // 상단/배경/칩 렌더
    function paintGame(game){
      document.getElementById('title').textContent=game.title||game.id;
      document.getElementById('chip-name').textContent=game.title||'게임';
      const bioText = game.scenario_summary || game.scenario_detail || game.title || '';
      // bio 대신 game-narration 사용
      const narrationEl = document.getElementById('game-narration');
      if (narrationEl) {
        narrationEl.textContent = bioText.toString();
      }

      // 게임 배경 이미지: 백엔드에서 R2 public URL로 변환된 필드 우선 사용
      const img = game.image || 
                 game.background_image_url || 
                 (game.world_snapshot && game.world_snapshot.image_url) || 
                 '/assets/img/placeholder.jpg';
      dbg('[resolved img] '+img);
      safeSetHero(img);                                         // 히어로 이미지
      document.getElementById('bg').style.backgroundImage=`url("${img}")`; // 흐림 배경

      const wrap=document.querySelector('.chips');              // tags 칩
      wrap.querySelectorAll('.chip.extra').forEach(n=>n.remove());
      // tags 배열 처리
      if(game.tags && Array.isArray(game.tags)){
        game.tags.forEach(tag=>{
          if(tag){ const s=document.createElement('span'); s.className='chip extra'; s.textContent=tag; wrap.appendChild(s); }
        });
      }
    }

    // 채팅 메시지 DOM 유틸
    function escapeHtml(s){ 
      return String(s||'').replace(
        /[&<>"']/g,
        c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])
      );
    }
    function addUser(text){ 
      const chat=document.getElementById('chat'); 
      const row=document.createElement('div'); 
      row.className='msg me'; 
      
      // persona 정보 가져오기 (게임 세션의 player_persona)
      const persona = getActivePersonaForGame();
      
      // persona 뱃지 생성
      let personaBadge = '';
      if (persona) {
        let imageKey = persona.image_key || 'F01';
        if (imageKey && imageKey.startsWith('preset_')) {
          try {
            const match = imageKey.match(/preset_([MF]\d+)/);
            if (match) imageKey = match[1];
          } catch (e) {}
        }
        const personaImageUrl = `/assets/persona/${imageKey}.png`;
        personaBadge = `
          <div class="user-persona-badge" data-role="persona-badge-message">
            <img src="${personaImageUrl}" alt="${escapeHtml(persona.name || '')}" class="user-persona-avatar" onerror="this.src='/assets/persona/F01.png'" />
            <span class="user-persona-name" data-role="persona-name">${escapeHtml(persona.name || '')}</span>
          </div>
        `;
      }
      
      row.innerHTML=`<div class="bubble">${escapeHtml(text)}</div>${personaBadge}`; 
      chat.appendChild(row); 
      
      const chatContainer = document.querySelector('.game-chat-log');
      if (chatContainer) {
        chatContainer.scrollTop = chatContainer.scrollHeight;
      } else {
        chat.scrollTop = chat.scrollHeight;
      }
    }
    function addBot(text, name=null){  
      const chat=document.getElementById('chat'); 
      const row=document.createElement('div'); 
      row.className='msg'; 
      // 게임 배경 이미지: 백엔드에서 R2 public URL로 변환된 필드 우선 사용
      const img = CURRENT_GAME?.image || 
                 CURRENT_GAME?.background_image_url || 
                 (CURRENT_GAME?.world_snapshot && CURRENT_GAME.world_snapshot.image_url) || 
                 '/assets/img/placeholder.jpg';
      const nameLabel = name ? `<strong>${escapeHtml(name)}</strong>: ` : '';
      row.innerHTML=`<img class="avatar" src="${img}" alt="bot"/><div class="bubble">${nameLabel}${escapeHtml(text)}</div>`; 
      chat.appendChild(row); 
      chat.scrollTop=chat.scrollHeight; 
    }
    
    function renderGameHud(userInfo, charactersInfo) {
      if (!hudEl) return;
      
      const attrs = (userInfo && userInfo.attributes) || {};
      const hp = attrs.hp || {};
      const mp = attrs.mp || {};
      const items = (userInfo && userInfo.items) || {};
      const gold = items.gold ?? 0;
      const chars = Array.isArray(charactersInfo) ? charactersInfo : [];
      
      hudEl.innerHTML = `
        <div class="game-hud-section">
          <div class="game-hud-title">플레이어</div>
          <div>HP: ${hp.current ?? 0} / ${hp.max ?? 0}</div>
          <div>MP: ${mp.current ?? 0} / ${mp.max ?? 0}</div>
          <div>Gold: ${gold}</div>
        </div>
        <div class="game-hud-section">
          <div class="game-hud-title">동료 / NPC</div>
          ${
            chars.length === 0
              ? '<div class="game-hud-char">아직 동료가 없습니다.</div>'
              : chars
                  .map((c) => {
                    const snap = c.snapshot || {};
                    const name = snap.name || '???';
                    const a = snap.attributes || {};
                    const chp = a.hp || {};
                    const cmp = a.mp || {};
                    return `
                      <div class="game-hud-char">
                        <span class="game-hud-char-name">${escapeHtml(name)}</span>
                        <span class="game-hud-char-stats">
                          <span>HP ${chp.current ?? 0}/${chp.max ?? 0}</span>
                          <span>MP ${cmp.current ?? 0}/${cmp.max ?? 0}</span>
                        </span>
                      </div>
                    `;
                  })
                  .join('')
          }
        </div>
      `;
      // game-hero-stats는 flex 레이아웃 유지
      hudEl.style.display = 'flex';
      hudEl.style.gap = '24px';
      hudEl.style.color = '#f5f5f5';
    }

    // 토큰 관리
    const TOKEN_KEY = 'access_token';
    const USER_INFO_KEY = 'user_info_v2';

    function getToken() { return localStorage.getItem(TOKEN_KEY); }
    function isLoggedIn() { return !!getToken(); }

    async function getUserInfo() {
      const userInfoV2 = localStorage.getItem(USER_INFO_KEY);
      if (!userInfoV2) {
        return null;
      }

      try {
        const res = await fetch(`${API_BASE_URL}/v1/auth/validate-session`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: userInfoV2 }),
          credentials: "include",
        });

        if (res.ok) {
          return await res.json();
        }
        return null;
      } catch (err) {
        console.error('Failed to get user info:', err);
        return null;
      }
    }

    /**
     * 계정 상태 체크
     * - ok: true 면 채팅 가능
     * - ok: false 이면 reason 으로 상태 구분
     *   - 'login': 로그인 필요
     *   - 'lock': 계정 차단
     *   - 'use': 사용 불가
     */
    async function checkAccountStatus() {
      const token = getToken();
      const info  = await getUserInfo();

      console.log('[ACCOUNT] token:', !!token, 'info:', info);

      if (!token) return { ok: false, reason: 'login' };

      if (!info)  return { ok: false, reason: 'login' };

      const is_use = info.is_use || false;
      const is_lock = info.is_lock || false;

      console.log('[ACCOUNT] is_use:', is_use, 'is_lock:', is_lock);

      if (is_lock) return { ok: false, reason: 'lock' };
      if (!is_use) return { ok: false, reason: 'use' };

      return { ok: true, reason: null };
    }

    // 토스트 메시지 표시
    function showToast(msg='준비중입니다', ms=2000){
      const el = document.getElementById('toast');
      el.querySelector('.box').textContent = msg;
      el.classList.add('show');
      clearTimeout(showToast.tid);
      showToast.tid = setTimeout(() => el.classList.remove('show'), ms);
    }

    // 페르조나 이미지 URL 정규화 함수
    const R2_BASE = "https://pub-09b0f3cad63f4891868948d43f19febf.r2.dev";
    function resolvePersonaUrl(u) {
      if (!u) return "";
      if (u.startsWith("http://") || u.startsWith("https://")) return u;
      if (u.startsWith("/")) return `${R2_BASE}${u}`;
      return `${R2_BASE}/assets/persona/${u}`;
    }
    
    // 게임 세션의 활성 persona 반환 (persona_ref_id로 복구 지원)
    function getActivePersonaForGame() {
      // 1) 세션에 player_persona가 있으면 반환 (persona_id 체크로 필터링하지 않음)
      if (currentSession?.player_persona) {
        return currentSession.player_persona;
      }
      
      // 2) persona_ref_id로 PERSONAS_LIST에서 복구
      if (currentSession?.persona_ref_id && PERSONAS_LIST && PERSONAS_LIST.length > 0) {
        const matched = PERSONAS_LIST.find(p => 
          p.persona_ref_id === currentSession.persona_ref_id || 
          p._id === currentSession.persona_ref_id
        );
        
        if (matched) {
          return {
            persona_id: matched.persona_id,
            name: matched.name,
            gender: matched.gender,
            intro: matched.intro || matched.bio || matched.summary,
            image_url: matched.image_url || matched.image?.url || resolvePersonaUrl(`/assets/persona/${matched.image_key || matched.image?.key || 'F01'}.png`),
            image_key: matched.image_key || matched.image?.key
          };
        }
      }
      
      // 3) fallback: PERSONAS_LIST에서 default persona
      const ps = PERSONAS_LIST || [];
      const d = ps.find(p => p.is_default) || ps[0];
      if (d?.persona_id) {
        return {
          persona_id: d.persona_id,
          name: d.name,
          gender: d.gender,
          image_key: d.image_key || d.image?.key
        };
      }
      
      return null;
    }

    // 헤더의 persona 뱃지 갱신 (항상 버튼 표시)
    function refreshHeaderPersonaBadge() {
      const persona = getActivePersonaForGame();
      const badgeEl = document.getElementById('headerPersonaBadge');
      const avatarEl = document.getElementById('headerPersonaAvatar');
      const nameEl = document.getElementById('headerPersonaName');
      const personaBtn = document.getElementById('personaBtn');
      
      if (!badgeEl || !avatarEl || !nameEl) {
        console.warn('[PERSONA] Header elements not found');
        return;
      }
      
      console.log('[PERSONA] refreshHeaderPersonaBadge - persona:', persona);
      console.log('[PERSONA] refreshHeaderPersonaBadge - currentSession:', currentSession);
      
      if (!persona) {
        // persona가 없으면 Persona 버튼 표시
        badgeEl.style.display = 'none';
        if (personaBtn) {
          personaBtn.style.display = 'inline-block';
          personaBtn.textContent = 'Persona';
        }
        console.log('[PERSONA] No persona, showing Persona button');
        return;
      }
      
      // persona가 있으면 badge 표시
      badgeEl.style.display = 'flex';
      if (personaBtn) personaBtn.style.display = 'none';
      
      // 이미지 URL 처리 (image_key 또는 image_url)
      let imageUrl = '';
      if (persona.image_key) {
        imageUrl = resolvePersonaUrl(`/assets/persona/${persona.image_key}.png`);
      } else if (persona.image_url) {
        imageUrl = persona.image_url;
      } else {
        imageUrl = resolvePersonaUrl('/assets/persona/F01.png');
      }
      
      avatarEl.src = imageUrl;
      avatarEl.alt = persona.name || 'persona';
      avatarEl.onerror = function() {
        this.src = resolvePersonaUrl('/assets/persona/F01.png');
      };
      nameEl.textContent = persona.name || 'persona';
    }

    // 페르조나 프리뷰 텍스트 추출
    function getPersonaPreview(p) {
      if (p.bio) return p.bio;
      if (p.summary) return p.summary;
      if (p.detail) return p.detail.substring(0, 120) + (p.detail.length > 120 ? '...' : '');
      if (p.intro) return p.intro;
      return '';
    }

    // 페르조나 목록 조회
    async function fetchPersonas() {
      try {
        const token = localStorage.getItem('user_info_v2');
        const headers = { 'Content-Type': 'application/json' };
        if (token) {
          headers['X-User-Info-Token'] = token;
        }

        const res = await fetch(`${API_BASE_URL}/v1/users/me/personas`, {
          credentials: 'include',
          headers
        });

        if (!res.ok) {
          if (res.status === 401) {
            throw new Error('로그인이 필요합니다.');
          }
          throw new Error(`Failed to load: ${res.status}`);
        }

        const personas = await res.json();
        return personas;
      } catch (e) {
        console.error('[PERSONA] Load error:', e);
        throw e;
      }
    }

    // 페르조나 모달 열기
    async function openPersonaModal(forceOpen = false) {
      const modal = document.getElementById('personaModal');
      const body = document.getElementById('personaModalBody');
      const closeBtn = document.getElementById('personaModalClose');
      const cancelBtn = document.getElementById('personaCancelBtn');
      
      isPersonaModalForceOpen = forceOpen;
      
      if (forceOpen) {
        modal.classList.add('force-open');
        if (closeBtn) closeBtn.classList.add('hidden');
        if (cancelBtn) cancelBtn.style.display = 'none';
      } else {
        modal.classList.remove('force-open');
        if (closeBtn) closeBtn.classList.remove('hidden');
        if (cancelBtn) cancelBtn.style.display = 'inline-block';
      }
      
      modal.classList.add('show');
      SELECTED_PERSONA_ID = null;
      body.innerHTML = '<div class="modal-loading">로딩 중...</div>';

      try {
        PERSONAS_LIST = await fetchPersonas();
        renderPersonaList();
      } catch (e) {
        body.innerHTML = `<div class="modal-loading" style="color:#ef4444;">페르조나를 불러오는데 실패했습니다: ${e.message}</div>`;
        console.error('[PERSONA] Failed to load personas:', e);
      }
    }

    // 페르조나 목록 렌더링
    function renderPersonaList() {
      const body = document.getElementById('personaModalBody');
      const selectedInfo = document.getElementById('personaSelectedInfo');
      const confirmBtn = document.getElementById('personaConfirmBtn');
      const cancelBtn = document.getElementById('personaCancelBtn');
      
      if (PERSONAS_LIST.length === 0) {
        // 페르조나가 없을 때: 강제 모달 해제 및 탈출 버튼 제공
        isPersonaModalForceOpen = false;
        const modal = document.getElementById('personaModal');
        const closeBtn = document.getElementById('personaModalClose');
        
        if (modal) modal.classList.remove('force-open');
        if (closeBtn) closeBtn.classList.remove('hidden');
        if (cancelBtn) cancelBtn.style.display = 'inline-block';
        
        body.innerHTML = `
          <div style="text-align:center; padding:40px 20px;">
            <div style="font-size:16px; color:#f3f4f6; margin-bottom:24px;">페르조나가 없습니다.</div>
            <div style="font-size:14px; color:#94a3b8; margin-bottom:32px;">My 메뉴에서 페르조나를 생성해주세요.</div>
            <div style="display:flex; gap:12px; justify-content:center;">
              <button class="btn-modal primary" onclick="window.location.href='/my.html'">My로 이동</button>
            </div>
          </div>
        `;
        selectedInfo.style.display = 'none';
        if (confirmBtn) confirmBtn.style.display = 'none';
        return;
      }
      
      // confirmBtn 표시 (페르조나가 있을 때)
      if (confirmBtn) confirmBtn.style.display = 'inline-block';

      // 카드 UI로 렌더링
      body.innerHTML = `<div class="persona-list">${PERSONAS_LIST.map(p => {
        const genderText = {
          male: '남성',
          female: '여성',
          nonbinary: '논바이너리'
        }[p.gender] || '논바이너리';

        // image_key 처리
        let imageKey = p.image_key || 'F01';
        if (imageKey && imageKey.startsWith('preset_')) {
          try {
            const num = parseInt(imageKey.replace('preset_', ''));
            if (num <= 4 || num === 9 || num === 10 || num === 13 || num === 15) {
              const mIndex = num <= 4 ? num : (num === 9 ? 5 : num === 10 ? 6 : num === 13 ? 7 : 8);
              imageKey = `M${String(mIndex).padStart(2, '0')}`;
            } else {
              const fIndex = num <= 8 ? num - 4 : (num === 11 ? 3 : num === 12 ? 4 : num === 14 ? 5 : 6);
              imageKey = `F${String(fIndex).padStart(2, '0')}`;
            }
          } catch {
            imageKey = 'F01';
          }
        }
        const imageUrl = resolvePersonaUrl(`/assets/persona/${imageKey}.png`);
        const previewText = getPersonaPreview(p);
        const selected = SELECTED_PERSONA_ID === p.persona_id ? 'selected' : '';
        const defaultClass = p.is_default ? 'default' : '';

        return `
          <div class="persona-card ${selected} ${defaultClass}" onclick="selectPersona('${p.persona_id}')">
            <div class="persona-card-header">
              <img src="${imageUrl}" alt="${escapeHtml(p.name)}" class="persona-avatar" onerror="this.src='${resolvePersonaUrl('/assets/persona/F01.png')}'" />
              <div class="persona-info">
                <div class="persona-name">
                  ${p.is_default ? '<span class="persona-badge">기본</span>' : ''}
                  ${escapeHtml(p.name)}
                </div>
                <div class="persona-gender">${genderText}</div>
              </div>
            </div>
            ${previewText ? `<div class="persona-bio">${escapeHtml(previewText)}</div>` : ''}
          </div>
        `;
      }).join('')}</div>`;

      // 선택된 페르조나 정보 표시
      if (SELECTED_PERSONA_ID) {
        const selectedPersona = PERSONAS_LIST.find(p => p.persona_id === SELECTED_PERSONA_ID);
        if (selectedPersona) {
          selectedInfo.innerHTML = `선택됨: <strong>${escapeHtml(selectedPersona.name)}</strong>`;
          selectedInfo.style.display = 'block';
          confirmBtn.disabled = false;
        } else {
          selectedInfo.style.display = 'none';
          confirmBtn.disabled = true;
        }
      } else {
        selectedInfo.style.display = 'none';
        confirmBtn.disabled = true;
      }
    }

    // 페르조나 선택
    function selectPersona(personaId) {
      SELECTED_PERSONA_ID = personaId;
      renderPersonaList();
    }

    // 페르조나 모달 닫기
    function closePersonaModal() {
      if (isPersonaModalForceOpen) {
        // 강제 모달은 닫을 수 없음
        return;
      }
      
      const modal = document.getElementById('personaModal');
      modal.classList.remove('show');
      modal.classList.remove('force-open');
      SELECTED_PERSONA_ID = null;
      pendingPersonaSelection = null;
    }

    // 확인 다이얼로그 표시
    function showConfirmDialog(message, onConfirm) {
      const dialog = document.getElementById('confirmDialog');
      const messageEl = document.getElementById('confirmDialogMessage');
      
      if (messageEl) {
        messageEl.textContent = message;
      }
      
      dialog.onConfirmCallback = onConfirm;
      dialog.classList.add('show');
    }

    // 확인 다이얼로그 닫기
    function closeConfirmDialog(confirmed) {
      const dialog = document.getElementById('confirmDialog');
      dialog.classList.remove('show');
      
      if (confirmed && dialog.onConfirmCallback) {
        dialog.onConfirmCallback();
      }
      
      dialog.onConfirmCallback = null;
    }

    // 페르조나 선택 완료 (전투 중 확인 포함)
    async function confirmPersonaSelection() {
      if (!SELECTED_PERSONA_ID) {
        showToast('페르조나를 선택해주세요.');
        return;
      }

      if (!CURRENT_GAME || !CURRENT_GAME.id) {
        console.warn('[PERSONA] No game ID available');
        showToast('게임 정보를 찾을 수 없습니다.');
        return;
      }

      const selectedPersona = PERSONAS_LIST.find(p => p.persona_id === SELECTED_PERSONA_ID);
      if (!selectedPersona) {
        showToast('선택한 페르조나를 찾을 수 없습니다.');
        return;
      }

      // 전투 중인지 확인
      const inCombat = currentSession?.combat?.in_combat === true;
      
      if (inCombat) {
        // 전투 중이면 확인 다이얼로그 표시
        pendingPersonaSelection = selectedPersona;
        showConfirmDialog(
          '게임 중에 페르조나를 변경하면 이후 대사와 전투 판정에 즉시 영향을 줍니다. 정말 변경하시겠습니까?',
          () => applyPersonaToGame(selectedPersona)
        );
      } else {
        // 전투 중이 아니면 즉시 적용
        await applyPersonaToGame(selectedPersona);
      }
    }

    // 페르조나를 게임 세션에 적용
    async function applyPersonaToGame(persona) {
      if (!persona || !CURRENT_GAME || !CURRENT_GAME.id) {
        return;
      }

      const gameId = CURRENT_GAME.id;
      const confirmBtn = document.getElementById('personaConfirmBtn');
      const originalText = confirmBtn ? confirmBtn.textContent : '';
      
      if (confirmBtn) {
        confirmBtn.disabled = true;
        confirmBtn.textContent = '적용 중...';
      }

      try {
        // persona_ref_id 결정 (우선순위: persona_ref_id > _id > persona_id fallback)
        const refId = persona.persona_ref_id || persona._id || null;
        if (!refId) {
          console.warn('[PERSONA] persona_ref_id not found, using persona_id as fallback:', persona.persona_id);
          showToast('페르조나 참조 ID를 찾을 수 없어 임시 ID를 사용합니다.', 2000);
        }
        const finalRefId = refId || persona.persona_id;

        // Optimistic UI 업데이트
        if (currentSession) {
          currentSession.player_persona = {
            persona_id: persona.persona_id,
            name: persona.name,
            gender: persona.gender,
            intro: persona.intro || persona.bio || persona.summary,
            image_url: persona.image?.url || resolvePersonaUrl(`/assets/persona/${persona.image_key || 'F01'}.png`),
            image_key: persona.image_key || persona.image?.key
          };
          currentSession.persona_ref_id = finalRefId;
          
          // 헤더 badge 즉시 갱신
          refreshHeaderPersonaBadge();
          // 기존 메시지 배지도 갱신
          refreshPlayerPersonaBadgesInChat();
        }

        // 서버에 저장
        const token = localStorage.getItem('user_info_v2');
        const headers = { 'Content-Type': 'application/json' };
        if (token) {
          headers['X-User-Info-Token'] = token;
        }

        const res = await fetch(`${API_BASE_URL}/v1/games/${gameId}/persona`, {
          method: 'POST',
          credentials: 'include',
          headers,
          body: JSON.stringify({ persona_ref_id: finalRefId })
        });

        if (!res.ok) {
          const errorText = await res.text().catch(() => 'Unknown error');
          console.error(`[PERSONA] API error: ${res.status} ${errorText}`);
          showToast(`페르조나 적용 실패: HTTP ${res.status}`);
          // TODO: 롤백 (선택사항)
          return;
        }

        const data = await res.json().catch(() => ({}));
        console.log('[PERSONA] Successfully applied persona:', data);
        
        // 서버 응답으로 세션 업데이트 (canonical 데이터)
        if (currentSession && data.player_persona) {
          currentSession.player_persona = data.player_persona;
          currentSession.persona_ref_id = data.persona_ref_id;
          refreshHeaderPersonaBadge();
          refreshPlayerPersonaBadgesInChat();
        }
        
        showToast('페르조나가 적용되었습니다.');
        
        // 강제 모달이면 닫기 가능하도록 설정
        if (isPersonaModalForceOpen) {
          isPersonaModalForceOpen = false;
          const modal = document.getElementById('personaModal');
          const closeBtn = document.getElementById('personaModalClose');
          const cancelBtn = document.getElementById('personaCancelBtn');
          modal.classList.remove('force-open');
          if (closeBtn) closeBtn.classList.remove('hidden');
          if (cancelBtn) cancelBtn.style.display = 'inline-block';
        }
        
        closePersonaModal();
      } catch (e) {
        console.error('[PERSONA] Failed to apply persona:', e);
        showToast(`페르조나 적용 중 오류가 발생했습니다: ${e.message}`);
        // TODO: 롤백 (선택사항)
      } finally {
        if (confirmBtn) {
          confirmBtn.disabled = false;
          confirmBtn.textContent = originalText;
        }
        pendingPersonaSelection = null;
      }
    }

    // 현재 페이지가 /game 인지 여부
    const isGamePage = window.location.pathname.startsWith('/game') || window.location.pathname.includes('game.html');
    
    // 쿼리 파라미터에서 game_id 추출
    let GAME_ID = null;
    if (isGamePage) {
      const params = new URLSearchParams(window.location.search);
      const idParam = params.get('game') || params.get('game_id');
      if (idParam) {
        // 'game_1' 형식이면 숫자만 추출
        const match = idParam.match(/^game_(\d+)$/i);
        GAME_ID = match ? parseInt(match[1], 10) : parseInt(idParam, 10);
      } else if (CURRENT_GAME?.id) {
        GAME_ID = CURRENT_GAME.id;
      }
    }
    
    // HUD / 내레이션 영역 DOM
    const hudEl = document.getElementById('game-hud');
    const narrationEl = document.getElementById('game-narration');

    // 백엔드 LLM 호출
    async function askLLM(message, mode='trpg', choices=0){
      try {
      const token = getToken();
      const userInfoV2 = localStorage.getItem(USER_INFO_KEY);
      const headers = { 
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };
      
      // JWT 기반 인증 사용 (Authorization 헤더)
      if (token) {
        headers['Authorization'] = `Bearer ${token}`;
      }
      
      // 게임 페이지면 /v1/games/{id}/turn, 아니면 /v1/chat/
      const API_URL = isGamePage && GAME_ID
        ? `${API_BASE_URL}/v1/games/${GAME_ID}/turn`
        : `${API_BASE_URL}/v1/chat/`;
      
      // 게임 턴 API는 {user_message: ...} 형식, /chat은 {message: ...} 형식
      const payload = isGamePage && GAME_ID
        ? { user_message: message }
        : {
            message, mode,
            model:'trpg-gen', polish_model:'trpg-polish', choices,
            game_id: CURRENT_GAME?.id ?? null,
            game: CURRENT_GAME ? {
              id: CURRENT_GAME.id,
              title: CURRENT_GAME.title,
              scenario_summary: CURRENT_GAME.scenario_summary,
              scenario_detail: CURRENT_GAME.scenario_detail,
              tags: CURRENT_GAME.tags || [],
              world_snapshot: CURRENT_GAME.world_snapshot,
              characters: CURRENT_GAME.characters || [],
            } : null,
          };
        
        console.log('[askLLM] Request URL:', API_URL);
        console.log('[askLLM] API_BASE_URL:', API_BASE_URL);
        console.log('[askLLM] isGamePage:', isGamePage, 'GAME_ID:', GAME_ID);
        console.log('[askLLM] Payload:', payload);
        
        const r = await fetch(API_URL, {
          method: "POST",
          credentials: "include",
          headers: headers,
          body: JSON.stringify(payload),
        });
        
        console.log('[askLLM] Response status:', r.status, r.statusText);
        console.log('[askLLM] Response headers:', Object.fromEntries(r.headers.entries()));
        
        if (!r.ok) {
          const errorText = await r.text();
          console.error(`[askLLM] HTTP ${r.status} Error:`, errorText);
          throw new Error(`HTTP ${r.status}: ${errorText || 'Server error'}`);
        }
        
      const j = await r.json();
        console.log('[askLLM] Response JSON:', j);
      
      // 턴 수가 응답으로 오면 제목 갱신
      if (j && j.turn !== undefined) {
        updateScenarioTitle(j.turn);
      }
      
      // 디버그 출력
      if (j && j.debug_event) {
        console.log('[EVENT DEBUG]', j.debug_event);
      }
      
      // 게임 턴 API 응답 형식 처리
      if (isGamePage && GAME_ID) {
        // === TRPG 게임 모드 응답 처리 ===
        // 백엔드 응답에서 session을 직접 사용 (중복 방지: 세션 전체 교체)
        // 플레이어 메시지는 이미 백엔드에서 turn_logs에 포함되어 있으므로
        // 로컬로 추가하지 않고 백엔드가 내려준 session을 그대로 사용
        if (j.session) {
          // 백엔드 응답의 session을 그대로 사용 (중복 방지: 세션 전체 교체)
          const prevLength = currentSession?.turn_logs?.length || 0;
          currentSession = j.session;
          const newLength = currentSession.turn_logs.length;
          console.log("[DEBUG] Using session from response, turn_logs length:", prevLength, "->", newLength);
          
          // 1) HUD 업데이트
          renderHudFromSession(currentSession);
          
          // 2) 채팅 로그 업데이트 (delta append 방식 - 배지 유지)
          // 로컬 메시지 배열 없이 오직 session.turn_logs만 렌더링
          renderChatLogsFromSession(currentSession, { isInitialLoad: false });
          
          // 3) 내레이션 업데이트
          if (narrationEl) {
            const lastNarration = currentSession.turn_logs
              .filter(log => log.speaker_type === 'narration')
              .pop();
            if (lastNarration) {
              narrationEl.textContent = lastNarration.text;
            }
          }
        } else {
          // 폴백: 세션을 다시 로드 (하지만 중복 방지를 위해 한 번만)
          console.warn('[askLLM] j.session not found, loading from API');
          const sessionData = await loadSession(GAME_ID);
          if (sessionData) {
            const prevLength = currentSession?.turn_logs?.length || 0;
            currentSession = sessionData;
            const newLength = currentSession.turn_logs.length;
            console.log("[DEBUG] Loaded session from API, turn_logs length:", prevLength, "->", newLength);
            renderHudFromSession(currentSession);
            renderChatLogsFromSession(currentSession, { isInitialLoad: false });
            if (narrationEl) {
              const lastNarration = currentSession.turn_logs
                .filter(log => log.speaker_type === 'narration')
                .pop();
              if (lastNarration) {
                narrationEl.textContent = lastNarration.text;
              }
            }
          } else {
            console.warn('[askLLM] Session data not available');
          }
        }
        
        return (j.narration || '').trim();
      } else {
        // === 기존 세계관 / 일반 채팅 응답 처리 ===
        const answer = j?.answer || j?.message || j?.content || (typeof j === 'string' ? j : '');
        if (answer) {
          addBot(answer);
        }
        return answer;
      }
      } catch(e) {
        console.error('[askLLM] Error:', e);
        console.error('[askLLM] Error stack:', e.stack);
        const errorMsg = e.message || String(e);
        return `(오류 발생) ${errorMsg}`;
      }
    }

    // 세션 상태 관리
    let currentSession = null;

    // 세션 로딩
    // 턴 수 표시 업데이트 함수
    const scenarioTitleEl = document.querySelector('#game-intro-title');
    
    function updateScenarioTitle(turn) {
      if (!scenarioTitleEl) return;
      
      const t = Number(turn || 0);
      if (!t || t <= 0) {
        scenarioTitleEl.textContent = '소개';
      } else {
        scenarioTitleEl.textContent = `소개 - [${t}턴]`;
      }
    }

    async function loadSession(gameId) {
      try {
        const userInfoV2 = localStorage.getItem(USER_INFO_KEY);
        const headers = { 'Content-Type': 'application/json' };
        
        // user_info_v2 토큰을 헤더에 추가
        if (userInfoV2) {
          headers['X-User-Info-Token'] = userInfoV2;
        }
        
        const res = await fetch(`${API_BASE_URL}/v1/games/${gameId}/session`, {
          method: 'GET',
          credentials: 'include',
          headers: headers,
        });
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        const data = await res.json();
        
        // 턴 수가 응답으로 오면 제목 갱신
        if (data && data.turn !== undefined) {
          updateScenarioTitle(data.turn);
        }
        
        return data;
      } catch (error) {
        console.error('[loadSession] Error:', error);
        return null;
      }
    }

    // 세션 기반 HUD 렌더링
    function renderHudFromSession(session) {
      if (!session || !hudEl) return;
      
      const player = session.player;
      const npcs = session.npcs || [];
      
      hudEl.innerHTML = `
        <div class="game-hud-section">
          <div class="game-hud-title">플레이어</div>
          <div>HP: ${player.hp} / ${player.hp_max}</div>
          <div>MP: ${player.mp} / ${player.mp_max}</div>
          <div>Gold: ${player.gold}</div>
        </div>
        <div class="game-hud-section">
          <div class="game-hud-title">동료 / NPC</div>
          ${
            npcs.length === 0
              ? '<div class="game-hud-char">아직 동료가 없습니다.</div>'
              : npcs
                  .map((npc) => {
                    return `
                      <div class="game-hud-char">
                        <span class="game-hud-char-name">${escapeHtml(npc.name)}</span>
                        <span class="game-hud-char-stats">
                          <span>HP ${npc.hp}/${npc.hp_max}</span>
                          <span>MP ${npc.mp}/${npc.mp_max}</span>
                        </span>
                      </div>
                    `;
                  })
                  .join('')
          }
        </div>
      `;
      hudEl.style.display = 'flex';
      hudEl.style.gap = '24px';
      hudEl.style.color = '#f5f5f5';
    }

    // 캐릭터 맵 생성 (characters_info 기반 - id와 name 둘 다로 매핑)
    // 반드시 session.characters_info만 사용 (game.characters_info 제거)
    function buildCharacterMaps(session) {
      const infoList = session?.characters_info || [];
      
      // id로 매핑하는 맵
      const byId = new Map();
      // name으로 매핑하는 맵
      const byName = new Map();
      
      // session.characters_info만 사용
      infoList.forEach((c) => {
        const snap = c.snapshot;
        if (!snap) return;
        
        const charId = Number(c.char_ref_id);
        if (!Number.isNaN(charId) && charId) {
          byId.set(charId, snap);
        }
        if (snap.name) {
          byName.set(snap.name.trim(), snap);
        }
      });
      
      console.log("[DEBUG] characterMaps", { 
        infoList,
        byId: Array.from(byId.entries()),
        byName: Array.from(byName.entries())
      });
      
      return { byId, byName };
    }

    // 아바타 URL 계산 함수 (페이지 레벨에서 계산)
    function getAvatarForLog(log, characterMaps, session) {
      const { byId, byName } = characterMaps;
      
      let rawUrl = null;
      let name = log.speaker_name || undefined;
      
      if (log.speaker_type === 'npc' || log.speaker_type === 'monster') {
        const id = log.speaker_id != null ? Number(log.speaker_id) : NaN;
        let snapshot = null;
        
        // 1차: speaker_id로 찾기
        if (!Number.isNaN(id)) {
          snapshot = byId.get(id);
        }
        
        // 2차: speaker_name으로 찾기
        if (!snapshot && name) {
          snapshot = byName.get(name.trim());
        }
        
        // 3차: 세션의 npcs에서 찾기 (fallback)
        if (!snapshot && log.speaker_id != null) {
          const npc = session.npcs?.find(n => n.id === Number(log.speaker_id));
          if (npc) {
            snapshot = { image_url: npc.image_url, name: npc.name };
          }
        }
        
        if (snapshot) {
          rawUrl = snapshot.image_url || null;
          if (!name) name = snapshot.name || 'NPC';
        } else {
          if (!name) name = 'NPC';
        }
      } else if (log.speaker_type === 'player') {
        rawUrl = null; // 플레이어는 아바타 없음
        if (!name) name = '플레이어';
      }
      
      // 배경 이미지처럼 처리: 이미 풀 URL이면 그대로 사용, 아니면 resolveAssetUrl로 변환
      let avatarUrl = '';
      if (rawUrl) {
        // 이미 풀 URL이면 그대로 사용 (배경 이미지와 동일한 방식)
        if (rawUrl.startsWith("http://") || rawUrl.startsWith("https://")) {
          avatarUrl = rawUrl;
        } else {
          // 상대 경로면 R2 Public URL로 변환
          avatarUrl = resolveAssetUrl(rawUrl);
        }
      } else {
        avatarUrl = resolveAssetUrl('/assets/img/placeholder.jpg');
      }
      
      console.log("[DEBUG] avatarForLog", { 
        log: { speaker_type: log.speaker_type, speaker_id: log.speaker_id, speaker_name: log.speaker_name },
        rawUrl,
        avatarUrl,
        name
      });
      
      return { avatarUrl, name };
    }

    // 중복 메시지 필터링 함수
    function dedupeMessages(messages) {
      const seen = new Map();
      
      const normalize = (t) => {
        if (!t || typeof t !== 'string') return '';
        return t.replace(/[.!\s]+$/g, "");  // 끝의 . ! 공백 제거
      };
      
      return messages.filter(msg => {
        // turn, speaker_type, speaker_id, text로 고유 키 생성
        const turn = msg.turn || 0;
        const speakerType = msg.speaker_type || '';
        const speakerId = msg.speaker_id || '';
        const normalizedText = normalize(msg.text || '');
        const key = `${turn}-${speakerType}-${speakerId}-${normalizedText}`;
        
        if (seen.has(key)) {
          console.log("[DEBUG] Dedupe: skipping duplicate message", key);
          return false;
        }
        seen.set(key, true);
        return true;
      });
    }

    // 게임 메시지 ID 생성 (안정적 ID 보장)
    function getGameMessageId(log) {
      if (log.id) return String(log.id);
      return `${log.turn || 0}-${log.speaker_type || 'unknown'}-${log.speaker_id || ''}`;
    }

    // 메시지 role 분류 (player/npc/narrator) - action은 modifier로 처리
    function getLogRole(log) {
      const st = String(log?.speaker_type ?? '').toLowerCase();
      if (st === 'player') return 'player';
      if (st === 'npc' || st === 'monster') return 'npc';
      return 'narrator';
    }

    // persona 미니 배지 생성 (스탬프 스타일)
    function createMiniPersonaBadge(persona) {
      if (!persona) return null;

      const badge = document.createElement('div');
      badge.className = 'persona-badge persona-badge--mini';
      badge.title = `${persona.name ?? 'persona'}`;

      // persona 이미지 URL 생성 (다양한 입력 구조 지원, resolvePersonaUrl로 통일)
      let src = '';
      // 우선순위: image_url > image?.url > image_key > image?.key > fallback
      if (persona.image_url) {
        src = persona.image_url;
      } else if (persona.image?.url) {
        src = persona.image.url;
      } else {
        let key = persona.image_key || persona.image?.key || '';
        if (key && key.startsWith('preset_')) {
          const m = key.match(/preset_([MF]\d+)/);
          if (m) key = m[1];
        }
        // resolvePersonaUrl은 /assets/persona/... 형태의 경로를 받음
        if (key) {
          src = resolvePersonaUrl(`/assets/persona/${key}.png`);
        } else {
          // 최종 fallback
          src = resolvePersonaUrl('/assets/persona/F01.png');
        }
      }

      if (src) {
        const img = document.createElement('img');
        img.src = src;
        img.alt = persona.name ?? 'persona';
        img.onerror = function() {
          this.src = resolvePersonaUrl('/assets/persona/F01.png');
        };
        badge.appendChild(img);
      } else {
        badge.textContent = String(persona.name ?? 'P').slice(0, 1).toUpperCase();
      }

      return badge;
    }

    // 게임 메시지 노드 생성 (role + action modifier 방식)
    function createGameMessageElement(log, session) {
      const role = getLogRole(log);
      const isAction = !!log?.is_action;
      const messageId = getGameMessageId(log);

      // 공통 row (role + action modifier)
      const row = document.createElement('div');
      row.className = `game-msg game-msg--${role}` + (isAction ? ' game-msg--action' : '');
      row.setAttribute('data-message-id', messageId);
      row.dataset.turn = String(log?.turn ?? '');
      row.dataset.speakerType = String(log?.speaker_type ?? '');
      row.dataset.isAction = String(isAction);

      // ✅ NPC: 아바타를 bubble "밖(좌측)"에 붙이기
      if (role === 'npc') {
        try {
          const characterMaps = buildCharacterMaps(session);
          const { avatarUrl, name } = getAvatarForLog(log, characterMaps, session);

          const av = document.createElement('div');
          av.className = 'game-avatar';
          av.title = name || 'NPC';

          if (avatarUrl) {
            av.style.backgroundImage = `url("${avatarUrl}")`;
          } else {
            av.textContent = (name || 'N').slice(0, 1).toUpperCase();
            av.classList.add('game-avatar--fallback');
          }

          row.appendChild(av);
        } catch (e) {
          console.warn('[createGameMessageElement] NPC avatar creation failed:', e);
        }
      }

      // bubble/card
      const bubble = document.createElement('div');
      bubble.className = 'game-bubble';

      // ✅ action UI는 role 유지한 채로 modifier일 때만
      if (isAction) {
        const head = document.createElement('div');
        head.className = 'game-action-head';
        head.textContent = 'ACTION';
        bubble.appendChild(head);
      }

      // 내용
      const content = document.createElement('div');
      content.className = 'game-content';
      
      // renderMessageText() 사용 (기존 로직 유지)
      const textContent = renderMessageText(log?.text ?? '');
      if (textContent.includes('<em>')) {
        content.innerHTML = textContent;
      } else {
        content.textContent = log?.text ?? '';
      }
      bubble.appendChild(content);

      // ✅ player: is_action 여부와 무관하게 항상 persona badge
      if (role === 'player') {
        const persona = getActivePersonaForGame();
        const badge = createMiniPersonaBadge(persona);
        if (badge) bubble.appendChild(badge);
      }

      // ✅ narrator: narrator 표식(작게)
      if (role === 'narrator') {
        const tag = document.createElement('div');
        tag.className = 'game-narrator-tag';
        tag.textContent = 'NARRATOR';
        bubble.appendChild(tag);
      }

      row.appendChild(bubble);
      return row;
    }

    // 게임 메시지 노드를 채팅 컨테이너에 append
    function appendGameMessage(log, session) {
      const chatEl = document.getElementById('chat');
      if (!chatEl) return;
      
      const row = createGameMessageElement(log, session);
      chatEl.appendChild(row);
      
      // 기존 스크롤 정책 유지 (자동 바닥)
      const chatContainer = document.querySelector('.game-chat-log');
      if (chatContainer) {
        setTimeout(() => {
          const bottomMarker = document.getElementById('chat-bottom-marker');
          if (bottomMarker) {
            bottomMarker.scrollIntoView({ behavior: 'smooth', block: 'end' });
          } else {
            chatContainer.scrollTop = chatContainer.scrollHeight;
          }
        }, 50);
      }
    }

    // 세션 기반 채팅 로그 렌더링 (delta append 방식 - 배지 유지)
    function renderChatLogsFromSession(session, opts = { isInitialLoad: false }) {
      if (!session) {
        console.warn("[DEBUG] renderChatLogsFromSession: no session");
        return;
      }
      
      const chatEl = document.getElementById('chat');
      if (!chatEl) {
        console.warn("[DEBUG] renderChatLogsFromSession: chat element not found");
        return;
      }
      
      // 초기 로드 시에만 전체 비우기 (업데이트 시에는 비우지 않음)
      if (opts.isInitialLoad) {
        const beforeLength = chatEl.children.length;
        chatEl.innerHTML = '';
        console.log("[DEBUG] renderChatLogsFromSession: initial load, cleared", beforeLength, "existing messages");
      } else {
        // 업데이트 모드: 기존 메시지 ID 수집 (존재하는 메시지 추적)
        const existingIds = new Set(
          Array.from(chatEl.querySelectorAll('[data-message-id]'))
            .map(el => el.getAttribute('data-message-id'))
            .filter(Boolean)
        );
        console.log("[DEBUG] renderChatLogsFromSession: update mode, existing messages:", existingIds.size);
        
        // 세션의 turn_logs에서 중복 제거
        const rawLogs = session.turn_logs || [];
        const logs = dedupeMessages(rawLogs);
        
        // 아직 없는 메시지만 append (delta append)
        let newCount = 0;
        logs.forEach((log) => {
          if (log.speaker_type === 'narration') {
            return;
          }
          
          const messageId = getGameMessageId(log);
          if (!existingIds.has(messageId)) {
            appendGameMessage(log, session);
            newCount++;
          }
        });
        console.log("[DEBUG] renderChatLogsFromSession: appended", newCount, "new messages");
        
        // 선택지 버튼 처리 (마지막 턴만)
        const actionsEl = document.getElementById('game-turn-actions');
        if (actionsEl && logs.length > 0) {
          const lastLog = logs[logs.length - 1];
          const choices = lastLog?.choices || lastLog?.meta?.choices || [];
          if (choices.length > 0) {
            actionsEl.innerHTML = '';
            choices.forEach((choice) => {
              const btn = document.createElement('button');
              btn.textContent = choice.text || choice;
              btn.onclick = () => {
                const choiceText = choice.text || choice;
                const ta = document.getElementById('ta');
                if (ta) {
                  ta.value = choiceText;
                  const sendBtn = document.getElementById('send');
                  if (sendBtn) sendBtn.click();
                }
              };
              actionsEl.appendChild(btn);
            });
          }
        }
        
        return; // 업데이트 모드는 여기서 종료
      }
      
      // 초기 로드 모드: 전체 렌더링
      // 캐릭터 맵 생성 (id와 name 둘 다로 매핑) - session만 사용
      const characterMaps = buildCharacterMaps(session);
      
      // 세션의 turn_logs를 렌더링 (오직 session.turn_logs만 사용)
      // 중복 메시지 필터링 적용
      const rawLogs = session.turn_logs || [];
      const logs = dedupeMessages(rawLogs);
      console.log("[DEBUG] turn_logs length", rawLogs.length, "-> deduped", logs.length);
      
      logs.forEach((log) => {
        if (log.speaker_type === 'narration') {
          // 내레이션은 별도 처리하지 않음 (노란 영역에만 표시)
          return;
        }
        
        appendGameMessage(log, session);
      });
      
      // 마지막 턴의 선택지 처리 (한 번만, 중복 방지)
      const actionsEl = document.getElementById('game-turn-actions');
      if (logs.length > 0 && actionsEl) {
        const lastLog = logs[logs.length - 1];
        const choices = lastLog?.choices || lastLog?.meta?.choices || [];
        console.log("[DEBUG] Rendering choices for last log:", choices.length, "choices");
        if (choices.length > 0) {
          // 중복 방지: 기존 버튼 제거 후 추가
          actionsEl.innerHTML = '';
          choices.forEach((choice, index) => {
            const btn = document.createElement('button');
            btn.textContent = choice.text || choice;
            btn.onclick = () => {
              const choiceText = choice.text || choice;
              const ta = document.getElementById('ta');
              if (ta) {
                ta.value = choiceText;
                const sendBtn = document.getElementById('send');
                if (sendBtn) sendBtn.click();
              }
            };
            actionsEl.appendChild(btn);
          });
        }
      }
      
      // 자동 스크롤 (하단 마커로) - 약간의 지연을 두어 DOM 업데이트 완료 후 실행
      // window.scrollTo는 사용하지 않고, 채팅 컨테이너 내부에서만 스크롤
      setTimeout(() => {
        const bottomMarker = document.getElementById('chat-bottom-marker');
        const chatContainer = chatEl.closest('.game-chat-log');
        if (bottomMarker && chatContainer) {
          // 채팅 로그 컨테이너 내부에서만 스크롤
          bottomMarker.scrollIntoView({ behavior: 'smooth', block: 'end' });
        } else if (chatEl) {
          // 폴백: 직접 스크롤
          chatEl.scrollTop = chatEl.scrollHeight;
        }
      }, 100);
    }

    // 메시지 텍스트 렌더링 (*대사* → 기울임체)
    function renderMessageText(text) {
      if (!text) return '';
      
      // *텍스트* 패턴 찾기
      const actionPattern = /^\*(.+?)\*$/;
      const match = text.match(actionPattern);
      
      if (match && match[1]) {
        return `<em>${escapeHtml(match[1])}</em>`;
      }
      
      return escapeHtml(text);
    }

    // player 메시지 배지 후처리 (personas 로딩 타이밍 문제 복구)
    function refreshPlayerPersonaBadgesInChat() {
      try {
        const persona = getActivePersonaForGame();
        const playerBubbles = document.querySelectorAll('.game-msg--player .game-bubble');
        let fixed = 0;

        playerBubbles.forEach(bubble => {
          // 이미 배지가 있으면 skip
          if (bubble.querySelector('.persona-badge--mini')) return;

          const badge = createMiniPersonaBadge(persona);
          if (badge) {
            bubble.appendChild(badge);
            fixed++;
          }
        });

        console.log('[PERSONA] refreshPlayerPersonaBadgesInChat fixed:', fixed, 'persona:', persona);
        return fixed;
      } catch (e) {
        console.warn('[PERSONA] refreshPlayerPersonaBadgesInChat failed:', e);
        return 0;
      }
    }

    // 초기화
    // .top-hud(.game-hero-card) width 동기화 함수
    // 주의: CSS game-inner-width로 고정 폭을 사용하므로 동적 width 설정은 제거
    // function syncHudWidth() {
    //   const topHud = document.querySelector('.top-hud') || document.querySelector('.game-hero-card');
    //   if (topHud) {
    //     const hudWidth = topHud.clientWidth;
    //     document.documentElement.style.setProperty('--hud-width', hudWidth + 'px');
    //     console.log('[HUD Width] Synced to:', hudWidth + 'px');
    //   }
    // }

    // 페이지 로드 시 및 리사이즈 시 HUD 폭 동기화
    // CSS game-inner-width로 고정 폭을 사용하므로 제거
    // window.addEventListener('resize', () => {
    //   syncHudWidth();
    // });

    document.addEventListener('DOMContentLoaded', async ()=>{
      // HUD 폭 동기화 제거 - CSS game-inner-width로 고정 폭 사용
      // syncHudWidth();
      console.log("[DEBUG] Rendering game chat template - apps/web-html/game.html");
      
      // 뒤로가기
      document.getElementById('backBtn').onclick=()=>{ if(history.length>1) history.back(); else location.href='/home.html'; };
      
      // Persona 버튼 클릭 이벤트
      const personaBtn = document.getElementById('personaBtn');
      const headerPersonaBadge = document.getElementById('headerPersonaBadge');
      if (personaBtn) personaBtn.onclick = () => openPersonaModal(false);
      if (headerPersonaBadge) headerPersonaBadge.onclick = () => openPersonaModal(false);
      
      // 모달 backdrop 클릭으로 닫기 (강제 모달이 아닐 때만)
      document.getElementById('personaModal').addEventListener('click', (e) => {
        if (e.target.id === 'personaModal' && !isPersonaModalForceOpen) {
          closePersonaModal();
        }
      });

      // URL → 게임 id 정규화
      const raw  = qs('game') || qs('game_id') || null;
      const norm = normalizeGameId(raw) || 1;
      dbg('[param] raw='+raw+' norm='+norm);

      // 상세 API 호출
      let game=null;
      try { game = await fetchGame(norm); }
      catch(e){ dbg('[error] '+e.message); game = {id:norm, title:'미확인 게임', background_image_path:'/assets/img/placeholder.jpg', scenario_summary:'정보 없음'}; }
      CURRENT_GAME = game;
      paintGame(game);
      
      // 이미지 로드 후 HUD 폭 재동기화 제거 - CSS game-inner-width로 고정 폭 사용
      // setTimeout(() => {
      //   syncHudWidth();
      // }, 100);
      
      // 세션 로딩 (초기 로드만 - gameId만 의존성, session/turn_logs는 의존성에 넣지 않음)
      const sessionData = await loadSession(norm);
      if (sessionData) {
        // 최초 세션 로드 시 턴 수 표시
        if (sessionData.turn !== undefined) {
          updateScenarioTitle(sessionData.turn);
        }
        // 백엔드가 세션 객체를 직접 반환하므로 그대로 사용
        currentSession = sessionData;
        console.log("[DEBUG] Initial session load, turn_logs length:", currentSession.turn_logs.length);
        
        // 1) HUD 먼저
        renderHudFromSession(currentSession);
        
        // 2) personas 먼저 로드 (가능하면 여기서)
        try {
          PERSONAS_LIST = await fetchPersonas();
        } catch (e) {
          console.warn('[GAME][BOOTSTRAP] Failed to load personas:', e);
        }
        
        // 3) header 갱신
        refreshHeaderPersonaBadge();
        
        // 4) 채팅 렌더 (이 시점에는 PERSONAS_LIST가 채워져서 배지 생성 가능)
        renderChatLogsFromSession(currentSession, { isInitialLoad: true });
        
        // 5) 혹시 still null 케이스(세션에 player_persona 있고 personas 없어도) 대비 후처리 한번 더
        refreshPlayerPersonaBadgesInChat();
        
        // 내레이션 영역 업데이트
        if (narrationEl && currentSession.turn_logs.length > 0) {
          const lastNarration = currentSession.turn_logs
            .filter(log => log.speaker_type === 'narration')
            .pop();
          if (lastNarration) {
            narrationEl.textContent = lastNarration.text;
          }
        }
        
        // persona가 없으면 강제 모달 열기 (페르조나 목록이 있을 때만 강제)
        const needsPersona = !currentSession.player_persona && !currentSession.persona_ref_id;
        const hasPersonas = (PERSONAS_LIST?.length ?? 0) > 0;
        
        if (needsPersona && hasPersonas) {
          console.log('[PERSONA] No persona found in session, forcing modal open');
          await openPersonaModal(true);
        } else if (needsPersona && !hasPersonas) {
          // 페르조나가 없으면 강제 모달 없이 일반 모달로 열기 (닫기 가능)
          console.log('[PERSONA] No persona found in session, opening modal (closable)');
          await openPersonaModal(false);
        }
      } else {
        // 초기 내레이션 영역에 게임 소개 텍스트 설정
        if (narrationEl) {
          const initialText = game.scenario_summary || game.scenario_detail || game.title || '게임을 시작하세요.';
          narrationEl.textContent = initialText;
        }
        
        // 세션이 없어도 페르조나 목록 로드 및 헤더 badge 갱신 (헤더 badge용, 하지만 세션이 없으면 강제 모달은 열지 않음)
        try {
          PERSONAS_LIST = await fetchPersonas();
        } catch (e) {
          console.warn('[GAME][BOOTSTRAP] Failed to load personas:', e);
        }
        refreshHeaderPersonaBadge();
      }

      // 게임은 인사말 없이 자유롭게 채팅 시작

      // 입력 동작
      const ta=document.getElementById('ta'), btn=document.getElementById('send');
      
      // 비로그인 상태에서 입력/전송 시도 시 계정 상태 체크
      async function checkLoginAndSend(){
        const status = await checkAccountStatus();

        if (!status.ok) {
          if (status.reason === 'login') {
            showToast('로그인이 필요합니다.', 2000);
          } else if (status.reason === 'lock') {
            showToast('현재 계정이 차단된 상태입니다.', 2000);
          } else if (status.reason === 'use') {
            showToast('현재 사용이 불가한 상태입니다.', 2000);
          } else {
            showToast('계정 상태를 확인할 수 없습니다.', 2000);
          }
          ta.blur();
          return false;
        }
        return true;
      }

      async function send(){
        // 로그인 체크
        if (!(await checkLoginAndSend())) return;
        
        const v=ta.value.trim(); if(!v)return;
        
        // 플레이어 메시지는 세션에 포함되므로 여기서 추가하지 않음
        // (백엔드에서 turn_logs에 추가되고, askLLM에서 세션 재로드 시 렌더링됨)
        
        ta.value=''; btn.disabled=true;
        
        console.log('[send] Starting API call with message:', v);
        console.log('[send] API_BASE_URL:', API_BASE_URL);
        console.log('[send] isGamePage:', isGamePage, 'GAME_ID:', GAME_ID);
        
        try{ 
          const ans=await askLLM(v,'trpg');
          console.log('[send] Received answer:', ans);
          // 게임 페이지가 아닐 때만 addBot 호출 (게임 페이지는 askLLM 내부에서 처리)
          if (!isGamePage && ans) {
            addBot(ans||'(응답이 비어있습니다)');
          }
        }
        catch(e){ 
          console.error('[send] Error caught:', e);
          if (isGamePage && GAME_ID) {
            // 에러 메시지만 추가 (세션 재렌더링은 하지 않음)
            const chatEl = document.getElementById('chat');
            if (chatEl) {
              const row = document.createElement('div');
              row.className = 'msg';
              row.innerHTML = `<div class="bubble">서버 오류: ${escapeHtml(e.message)}</div>`;
              chatEl.appendChild(row);
              const bottomMarker = document.getElementById('chat-bottom-marker');
              if (bottomMarker) {
                bottomMarker.scrollIntoView({ behavior: 'smooth', block: 'end' });
              } else {
                chatEl.scrollTop = chatEl.scrollHeight;
              }
            }
          } else {
            addBot('서버 오류: '+e.message);
          }
        }
        finally{ 
          btn.disabled=false; 
          ta.focus(); 
        }
      }
      
      // 입력 필드 포커스 시 계정 상태 체크
      ta.addEventListener('focus', async (ev) => {
        const status = await checkAccountStatus();
        if (!status.ok) {
          ev.preventDefault();
          ta.blur();

          if (status.reason === 'login') {
            showToast('로그인이 필요합니다.', 2000);
          } else if (status.reason === 'lock') {
            showToast('현재 계정이 차단된 상태입니다.', 2000);
          } else if (status.reason === 'use') {
            showToast('현재 사용이 불가한 상태입니다.', 2000);
          } else {
            showToast('계정 상태를 확인할 수 없습니다.', 2000);
          }
        }
      });

      // 클릭 시도 시 계정 상태 체크
      ta.addEventListener('click', async (ev) => {
        const status = await checkAccountStatus();
        if (!status.ok) {
          ev.preventDefault();
          ta.blur();

          if (status.reason === 'login') {
            showToast('로그인이 필요합니다.', 2000);
          } else if (status.reason === 'lock') {
            showToast('현재 계정이 차단된 상태입니다.', 2000);
          } else if (status.reason === 'use') {
            showToast('현재 사용이 불가한 상태입니다.', 2000);
          } else {
            showToast('계정 상태를 확인할 수 없습니다.', 2000);
          }
        }
      });

      btn.onclick=send;
      ta.addEventListener('keydown', ev=>{ 
        if (ev.key==='Enter' && !ev.shiftKey){ 
          ev.preventDefault(); 
          send(); 
        }
      });
    });

    // 디버그 유틸: 게임 배지 상태 체크
    window.__debugGameBadges = function () {
      const playerRows = document.querySelectorAll('.game-msg--player').length;
      const miniBadges = document.querySelectorAll('.persona-badge--mini').length;
      const npcAvatars = document.querySelectorAll('.game-msg--npc .game-avatar').length;
      console.log({ 
        playerRows, 
        miniBadges, 
        npcAvatars, 
        currentSessionPersonaRef: currentSession?.persona_ref_id, 
        currentSessionPlayerPersona: currentSession?.player_persona 
      });
      return { playerRows, miniBadges, npcAvatars };
    };
  </script>
</body>
</html>



