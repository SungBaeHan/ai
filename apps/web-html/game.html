<!-- ========================================
     apps/web-html/game.html — 게임 상세(채팅) 화면
     - URL ?game=1 또는 ?game_id=1 지원
     - /v1/games/:id 단건 호출해서 렌더
     - 이미지 경로 보정(resolvePath)로 /assets/game/… 보장
     - 게임 채팅 시작
     ======================================== -->
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Game Chat • TRPG</title>
  <script src="/js/config.js"></script>
  <script src="/js/assets.js"></script>
  <script>
    // 전역 API 엔드포인트 설정 (어디서든 window.API_BASE_URL로 접근)
    window.API_BASE_URL = 'https://api.arcanaverse.ai';
    window.API_BASE = 'https://api.arcanaverse.ai';
    
    // 게임 ID 주입 (쿼리 파라미터에서 추출)
    (function() {
      const params = new URLSearchParams(window.location.search);
      const gameId = params.get('game') || params.get('game_id');
      if (gameId) {
        // 'game_1' 형식이면 숫자만 추출
        const match = gameId.match(/^game_(\d+)$/i);
        window.GAME_ID = match ? parseInt(match[1], 10) : parseInt(gameId, 10);
      }
    })();
  </script>
  <script src="/js/game_turn.js"></script>
  <style>
    :root { color-scheme: dark; } /* 다크 테마 힌트 */
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden; /* 전체 페이지는 스크롤 금지 */
    }
    body { 
      background:#0b0f14; 
      color:#e5e7eb; 
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,'Apple SD Gothic Neo','Malgun Gothic',sans-serif; 
    }
    .topbar-wrap { display:flex; justify-content:center; border-bottom:1px solid #1b2430; background:#0e141c; position:sticky; top:0; z-index:20; }
    .topbar { width:100%; max-width:980px; display:flex; align-items:center; gap:10px; padding:10px 14px; }
    .back { display:inline-flex; align-items:center; justify-content:center; width:36px; height:36px; border-radius:10px; border:1px solid #223042; background:#0f172a; color:#cbd5e1; cursor:pointer; }
    .title { font-weight:700; font-size:15px; color:#f1f5f9; }
    .hero { position:relative; margin:18px auto; max-width:980px; }
    .hero img { width:100%; border-radius:14px; border:1px solid #1f2937; box-shadow:0 10px 28px rgba(0,0,0,.35); display:block; }
    .panel { max-width:980px; margin:10px auto 18px; background:#0f172a; border:1px solid #1e293b; border-radius:12px; padding:12px 14px; }
    .chips { margin-top:6px; display:flex; gap:8px; flex-wrap:wrap; }
    .chip { padding:3px 8px; font-size:11px; border-radius:999px; border:1px solid #334155; color:#a5b4fc; background:#0b1220; }
    .hint { font-size:12px; color:#9ca3af; margin-top:6px; }
    /* game-hud-box는 game-hero-stats로 대체되었으므로 제거 */
    /* 기존 스타일은 game-hero-stats에 통합됨 */
    .game-hud-section {
      min-width:180px;
    }
    .game-hud-title {
      font-weight:600;
      margin-bottom:4px;
      opacity:0.7;
    }
    .game-hud-char {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-top:4px;
      font-size:12px;
    }
    .game-hud-char-name {
      font-weight:600;
      margin-right:8px;
    }
    .game-hud-char-stats {
      display:flex;
      gap:8px;
      opacity:0.85;
    }
    /* 전체 게임 페이지: 상단 고정 + 하단 스크롤을 위한 기본 레이아웃 */
    .game-page {
      display: flex;
      flex-direction: column;
      height: 100vh;          /* 전체 화면 꽉 채우기 */
      overflow: hidden;       /* 페이지 레벨 스크롤 방지 */
    }
    /* 상단 히어로 영역: 높이 제한하여 압축 */
    .game-hero {
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-height: 35vh;    /* 화면의 35%까지만 사용 (더 압축) */
      min-height: 200px;   /* 최소값 줄임 */
      z-index: 10;
      margin-bottom: 0;
      overflow: hidden;
    }
    /* 이미지 카드 전체 */
    .game-hero-card {
      position: relative;
      width: 100%;
      max-width: 900px; /* 카드의 실제 너비에 맞춰 조정 */
      margin: 0 auto;
      border-radius: 16px;
      overflow: hidden;
    }
    /* 이미지 */
    .game-hero-image {
      width: 100%;
      display: block;
      border-radius: 16px;
    }
    /* 소개 패널 (이미지+스탯 아래 배치) - 높이 제한 */
    .game-intro-panel {
      flex-shrink: 0;
      max-height: 100px;      /* 너무 길어지지 않게 (더 압축) */
      overflow: hidden;
      margin-top: 8px;
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
      background: #0f172a;
      border: 1px solid #1e293b;
      border-radius: 12px;
      padding: 8px 14px;  /* 패딩 줄임 */
      font-size: 0.9rem;  /* 폰트 크기 줄임 */
    }
    /* ⭐ 스탯 HUD 오버레이 */
    .game-hero-stats {
      position: absolute;
      bottom: 12px;                 /* 이미지 안에서의 아래쪽 위치 */
      left: 12px;
      right: 12px;                  /* 좌우 여백이 exactly 이미지 카드 폭에 맞도록 */
      padding: 14px 18px;
      border-radius: 12px;
      background: rgba(10, 12, 20, 0.80);  /* 반투명 HUD */
      backdrop-filter: blur(6px);
      color: #fff;
      z-index: 10;                  /* 이미지보다 위 */
      display: flex;
      gap: 24px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      font-size: 0.9rem;
    }
    /* 텍스트 너무 붙지 않도록 */
    .game-hero-stats table,
    .game-hero-stats div {
      width: 100%;
    }
    /* 하단: 채팅 영역 전체 */
    .game-body {
      flex: 1;                /* 남은 세로 공간 전부 차지 */
      display: flex;
      flex-direction: column;
      min-height: 0;          /* flex 컨테이너 안에서 overflow가 제대로 작동하게 */
      overflow: hidden;      /* 전체 페이지에서 넘치는 스크롤 방지 */
    }
    /* 소개 박스는 고정 높이 (너무 커지지 않게) */
    .game-intro-panel {
      flex-shrink: 0;
      max-height: 80px;  /* 더 압축 */
      overflow: hidden;
      margin-top: 4px;
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
      background: #0f172a;
      border: 1px solid #1e293b;
      border-radius: 12px;
      padding: 6px 14px;  /* 패딩 줄임 */
      font-size: 0.85rem;  /* 폰트 크기 줄임 */
    }
    /* 채팅 전체 컨테이너 */
    .game-chat {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    /* 채팅 로그는 스크롤 영역 - 입력창 위까지만 */
    .game-chat-log {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      padding: 12px 24px 16px;
      scrollbar-width: thin;  /* Firefox: 얇은 스크롤바 */
      scrollbar-color: rgba(255, 255, 255, 0.2) transparent;  /* Firefox: 투명 스크롤바 */
      /* max-height 제거 - flex: 1이 자동으로 높이 조절 */
    }
    .game-chat-log::-webkit-scrollbar {
      width: 8px;  /* 스크롤바 너비 (0 대신 얇게) */
      height: 8px;
    }
    .game-chat-log::-webkit-scrollbar-track {
      background: transparent;  /* 트랙 투명 */
    }
    .game-chat-log::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.2);  /* 스크롤바 투명 */
      border-radius: 4px;
    }
    .game-chat-log::-webkit-scrollbar-thumb:hover {
      background-color: rgba(255, 255, 255, 0.3);  /* 호버 시 약간 더 진하게 */
    }
    /* 입력창은 flex 하단에 고정 */
    .game-chat-input {
      flex-shrink: 0;
      padding: 8px 24px 16px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(2px);
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      /* position: fixed/absolute/bottom 제거 확인 - flex만 사용 */
    }
    /* 기존 채팅 스타일 유지 */
    #chat, #chat-log {
      max-width:980px;
      margin:0 auto;
      padding:0 4px;
    }
    /* 채팅 로그 영역 안에 자연스럽게 배치될 선택지 버튼 컨테이너 */
    .game-turn-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 16px 0 8px;
      max-width: 980px;
      margin-left: auto;
      margin-right: auto;
      padding: 0 4px;
    }
    /* 버튼이 위로 딸려가지 않도록 position 관련 스타일은 절대 넣지 말 것 */
    .game-turn-actions button {
      /* 기존 버튼 스타일 유지 */
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid #334155;
      background: #111827;
      color: #c7d2fe;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    .game-turn-actions button:hover {
      background: #1f2937;
      border-color: #475569;
    }
    .game-turn-actions button:active {
      transform: translateY(1px);
    }
    .msg { display:flex; align-items:flex-start; gap:10px; margin:14px 0; animation:fadeInUp .35s ease; }
    .msg.me { flex-direction:row-reverse; }
    .avatar { width:42px; height:42px; border-radius:50%; object-fit:cover; box-shadow:0 0 6px rgba(0,0,0,.4); }
    .bubble { background:#111827; border:1px solid #1f2937; padding:10px 14px; border-radius:14px; white-space:pre-wrap; line-height:1.6; max-width:70%; }
    .me .bubble { background:rgba(63,131,248,0.25); border-color:#334155; }
    .inputBar { 
      /* position:fixed 제거 - flex layout으로 처리 */
      border-top:1px solid #1b2430; 
      background:#0e141c; 
      padding:12px; 
    }
    .inputIn { max-width:980px; margin:0 auto; display:flex; gap:8px; }
    textarea { flex:1; resize:none; background:#0b1220; border:1px solid #1f2937; border-radius:10px; color:#e5e7eb; padding:10px 12px; min-height:44px; }
    button { padding:0 14px; border-radius:10px; border:1px solid #334155; background:#111827; color:#c7d2fe; height:44px; }
    button[disabled]{ opacity:.6; cursor:not-allowed; }
    .bg { position:fixed; inset:0; background-position:center; background-size:cover; opacity:.4; filter:blur(1.5px) brightness(0.9); z-index:-1; transition:filter .5s ease, opacity .5s ease; }
    .debug { max-width:980px; margin:6px auto 0; font-size:12px; color:#93c5fd; opacity:.9; white-space:pre-wrap; }
    /* toast layer */
    .toast { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; opacity:0; transition:opacity .18s ease; z-index:50; }
    .toast.show { opacity:1; }
    .toast .box { pointer-events:auto; min-width:200px; max-width:80vw; background:#0f172a; border:1px solid #1f2937; color:#e5e7eb; padding:14px 18px; border-radius:12px; box-shadow:0 12px 32px rgba(0,0,0,.45); text-align:center; }
    @keyframes fadeInUp { from { opacity:0; transform:translateY(12px); } to { opacity:1; transform:translateY(0); } }
  </style>
</head>
<body>
  <div class="bg" id="bg"></div> <!-- 흐림 배경 -->

  <div class="topbar-wrap">
    <div class="topbar">
      <button id="backBtn" class="back" title="뒤로 가기">←</button> <!-- 뒤로가기 -->
      <div class="title" id="title">로딩 중…</div>                   <!-- 게임 이름 -->
    </div>
  </div>

  <div id="game-page" class="game-page">
    <!-- 상단: 이미지 + 시나리오 + HUD(스탯) -->
    <section class="game-hero">
      <div class="game-hero-card">
        <img id="hero" class="game-hero-image" alt="cover" src="/assets/img/placeholder.jpg" /> <!-- 히어로 이미지 -->
        <div class="debug" id="dbg"></div> <!-- 디버그 로그(요청/이미지 경로) -->

        <!-- ⭐ HUD 스탯 패널 (이미지 위에 오버레이) -->
        <div id="game-hud" class="game-hero-stats">
          <div class="game-hud-section">
            <div class="game-hud-title">상태</div>
            <div class="game-hud-body">게임을 시작하면 상태가 표시됩니다.</div>
          </div>
        </div>
      </div>
    </section>

    <!-- 하단: 채팅 로그 + 입력창 -->
    <section class="game-body">
      <!-- 소개 박스 -->
      <div class="game-intro-panel">
        <div style="font-weight:700; margin-bottom:6px;">소개</div>
        <div id="game-narration" style="opacity:.9"></div> <!-- 내레이션 영역 -->
        <div class="chips">
          <span class="chip">TRPG</span>
          <span class="chip" id="chip-name">게임</span>
        </div>
        <div class="hint">Tip: 메세지를 보내면 게임 턴이 진행됩니다.</div>
      </div>

      <!-- 채팅 영역 (로그 + 입력창) -->
      <div class="game-chat">
        <div class="game-chat-log" id="chat-log">
          <div id="game-log-messages">
            <div class="chat" id="chat"></div> <!-- 채팅 로그 -->
            <div class="chat" id="chat-log-old" style="display:none;"></div> <!-- 턴 시스템용 채팅 로그 -->
          </div>
          <!-- ⭐ 선택지 버튼은 여기 -->
          <div id="game-turn-actions" class="game-turn-actions">
            <!-- JS가 여기 안에 버튼들을 append 하도록 유지 -->
          </div>
          <!-- 스크롤 하단 마커 (자동 스크롤용) -->
          <div id="chat-bottom-marker" style="height: 1px;"></div>
        </div>
        <div class="game-chat-input" id="chat-input">
          <div class="inputIn">
            <textarea id="ta" placeholder="메시지 입력…"></textarea>  <!-- 입력창 (기존) -->
            <textarea id="user-input" placeholder="메시지 입력…" style="display:none;"></textarea>  <!-- 턴 시스템용 입력창 -->
            <button id="send">보내기</button>                         <!-- 전송 (기존) -->
            <button id="send-btn" style="display:none;">보내기</button>  <!-- 턴 시스템용 전송 버튼 -->
          </div>
        </div>
      </div>
    </section>
  </div>

  <!-- Toast Layer -->
  <div id="toast" class="toast" aria-live="polite" aria-atomic="true">
    <div class="box">준비중입니다</div>
  </div>

  <script>
    // API_BASE_URL은 이미 위쪽에서 window.API_BASE_URL로 설정됨

    // --- 전역/유틸 -------------------------------------------------------------
    let CURRENT_GAME = null;  // 현재 게임
    const FALLBACK_SVG = 'data:image/svg+xml;utf8,' + encodeURIComponent(
      `<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="675"><rect width="100%" height="100%" fill="#0e141c"/><text x="50%" y="50%" fill="#94a3b8" font-size="48" font-family="sans-serif" text-anchor="middle" dominant-baseline="middle">No Image</text></svg>`
    );
    const dbg = (m) => { 
      const el=document.getElementById('dbg'); 
      // el.textContent = (el.textContent?el.textContent+"\n":"") + m; 
      // console.log(m); 
    };

    function qs(k){ return new URL(location.href).searchParams.get(k); } // 쿼리 파서

    // 'game_1' → 1 / '1' → 1
    function normalizeGameId(v){
      if(!v) return null;
      if(/^game_\d{1,6}$/i.test(v)) return parseInt(v.split('_')[1],10);
      if(/^\d+$/.test(v)) return parseInt(v,10);
      return v;
    }

    // 이미지 경로 보정 → 상대 경로를 풀 URL로 변환
    // R2 Public URL (배경 이미지와 동일한 방식)
    const R2_PUBLIC_URL = "https://pub-09b0f3cad63f4891868948d43f19febf.r2.dev";
    const ASSET_BASE_URL = window.location.origin; // => https://www.arcanaverse.ai
    
    function resolveAssetUrl(path) {
      if (!path) return "";
      // 이미 풀 URL이면 그대로 반환 (R2 URL 포함)
      if (path.startsWith("http://") || path.startsWith("https://")) return path;
      
      // 상대 경로(/assets/...)를 R2 Public URL로 변환 (배경 이미지와 동일)
      // 배경 이미지처럼 R2_PUBLIC_URL을 직접 사용
      if (path.startsWith("/")) {
        return `${R2_PUBLIC_URL}${path}`;
      }
      // 상대 경로가 /로 시작하지 않으면 /assets/char/ 또는 /assets/img/ 경로로 가정
      if (path.includes('/char/') || path.includes('char_')) {
        return `${R2_PUBLIC_URL}/assets/char/${path.replace(/^.*\/(char\/|char_)/, '').replace(/^.*\//, '')}`;
      }
      return `${R2_PUBLIC_URL}/assets/img/${path}`;
    }
    
    function resolvePath(p){
      if (!p) {
        return resolveAssetUrl('/assets/img/placeholder.jpg');
      }
      // 이미 풀 URL이면 그대로 반환
      if (/^https?:\/\//i.test(p)) return p;
      
      p = String(p).replace(/\\/g, '/').trim();
      
      // resolveAssetUrl 사용 (unreachable code 제거)
      return resolveAssetUrl(p);
    }

    // 안전한 hero 이미지 로더(404 시 SVG로 대체)
    function safeSetHero(imgUrl){
      const hero=document.getElementById('hero');
      hero.onerror=()=>{ dbg('[hero 404] '+imgUrl); hero.src=FALLBACK_SVG; };
      hero.onload =()=>{ dbg('[hero 200] '+imgUrl); };
      hero.src=imgUrl||'/assets/img/placeholder.jpg';
      dbg('[hero set] '+hero.src);
    }

    // 단일 게임 API 호출 (상세)
    async function fetchGame(id){
      dbg('[fetch] /v1/games/'+id);
      const r = await fetch(`${API_BASE_URL}/v1/games/${id}`, {
        method: "GET",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        cache: 'no-store'
      });
      dbg('[fetch status] '+r.status);
      if(!r.ok) throw new Error('게임 불러오기 실패: HTTP '+r.status);
      const j = await r.json();
      dbg('[fetch image] '+j.background_image_path);
      return j;
    }

    // 상단/배경/칩 렌더
    function paintGame(game){
      document.getElementById('title').textContent=game.title||game.id;
      document.getElementById('chip-name').textContent=game.title||'게임';
      const bioText = game.scenario_summary || game.scenario_detail || game.title || '';
      // bio 대신 game-narration 사용
      const narrationEl = document.getElementById('game-narration');
      if (narrationEl) {
        narrationEl.textContent = bioText.toString();
      }

      // 게임 배경 이미지: 백엔드에서 R2 public URL로 변환된 필드 우선 사용
      const img = game.image || 
                 game.background_image_url || 
                 (game.world_snapshot && game.world_snapshot.image_url) || 
                 '/assets/img/placeholder.jpg';
      dbg('[resolved img] '+img);
      safeSetHero(img);                                         // 히어로 이미지
      document.getElementById('bg').style.backgroundImage=`url("${img}")`; // 흐림 배경

      const wrap=document.querySelector('.chips');              // tags 칩
      wrap.querySelectorAll('.chip.extra').forEach(n=>n.remove());
      // tags 배열 처리
      if(game.tags && Array.isArray(game.tags)){
        game.tags.forEach(tag=>{
          if(tag){ const s=document.createElement('span'); s.className='chip extra'; s.textContent=tag; wrap.appendChild(s); }
        });
      }
    }

    // 채팅 메시지 DOM 유틸
    function escapeHtml(s){ 
      return String(s||'').replace(
        /[&<>"']/g,
        c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])
      );
    }
    function addUser(text){ const chat=document.getElementById('chat'); const row=document.createElement('div'); row.className='msg me'; row.innerHTML=`<div class="bubble">${escapeHtml(text)}</div>`; chat.appendChild(row); chat.scrollTop=chat.scrollHeight; }
    function addBot(text, name=null){  
      const chat=document.getElementById('chat'); 
      const row=document.createElement('div'); 
      row.className='msg'; 
      // 게임 배경 이미지: 백엔드에서 R2 public URL로 변환된 필드 우선 사용
      const img = CURRENT_GAME?.image || 
                 CURRENT_GAME?.background_image_url || 
                 (CURRENT_GAME?.world_snapshot && CURRENT_GAME.world_snapshot.image_url) || 
                 '/assets/img/placeholder.jpg';
      const nameLabel = name ? `<strong>${escapeHtml(name)}</strong>: ` : '';
      row.innerHTML=`<img class="avatar" src="${img}" alt="bot"/><div class="bubble">${nameLabel}${escapeHtml(text)}</div>`; 
      chat.appendChild(row); 
      chat.scrollTop=chat.scrollHeight; 
    }
    
    function renderGameHud(userInfo, charactersInfo) {
      if (!hudEl) return;
      
      const attrs = (userInfo && userInfo.attributes) || {};
      const hp = attrs.hp || {};
      const mp = attrs.mp || {};
      const items = (userInfo && userInfo.items) || {};
      const gold = items.gold ?? 0;
      const chars = Array.isArray(charactersInfo) ? charactersInfo : [];
      
      hudEl.innerHTML = `
        <div class="game-hud-section">
          <div class="game-hud-title">플레이어</div>
          <div>HP: ${hp.current ?? 0} / ${hp.max ?? 0}</div>
          <div>MP: ${mp.current ?? 0} / ${mp.max ?? 0}</div>
          <div>Gold: ${gold}</div>
        </div>
        <div class="game-hud-section">
          <div class="game-hud-title">동료 / NPC</div>
          ${
            chars.length === 0
              ? '<div class="game-hud-char">아직 동료가 없습니다.</div>'
              : chars
                  .map((c) => {
                    const snap = c.snapshot || {};
                    const name = snap.name || '???';
                    const a = snap.attributes || {};
                    const chp = a.hp || {};
                    const cmp = a.mp || {};
                    return `
                      <div class="game-hud-char">
                        <span class="game-hud-char-name">${escapeHtml(name)}</span>
                        <span class="game-hud-char-stats">
                          <span>HP ${chp.current ?? 0}/${chp.max ?? 0}</span>
                          <span>MP ${cmp.current ?? 0}/${cmp.max ?? 0}</span>
                        </span>
                      </div>
                    `;
                  })
                  .join('')
          }
        </div>
      `;
      // game-hero-stats는 flex 레이아웃 유지
      hudEl.style.display = 'flex';
      hudEl.style.gap = '24px';
      hudEl.style.color = '#f5f5f5';
    }

    // 토큰 관리
    const TOKEN_KEY = 'access_token';
    const USER_INFO_KEY = 'user_info_v2';

    function getToken() { return localStorage.getItem(TOKEN_KEY); }
    function isLoggedIn() { return !!getToken(); }

    async function getUserInfo() {
      const userInfoV2 = localStorage.getItem(USER_INFO_KEY);
      if (!userInfoV2) {
        return null;
      }

      try {
        const res = await fetch(`${API_BASE_URL}/v1/auth/validate-session`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: userInfoV2 }),
          credentials: "include",
        });

        if (res.ok) {
          return await res.json();
        }
        return null;
      } catch (err) {
        console.error('Failed to get user info:', err);
        return null;
      }
    }

    /**
     * 계정 상태 체크
     * - ok: true 면 채팅 가능
     * - ok: false 이면 reason 으로 상태 구분
     *   - 'login': 로그인 필요
     *   - 'lock': 계정 차단
     *   - 'use': 사용 불가
     */
    async function checkAccountStatus() {
      const token = getToken();
      const info  = await getUserInfo();

      console.log('[ACCOUNT] token:', !!token, 'info:', info);

      if (!token) return { ok: false, reason: 'login' };

      if (!info)  return { ok: false, reason: 'login' };

      const is_use = info.is_use || false;
      const is_lock = info.is_lock || false;

      console.log('[ACCOUNT] is_use:', is_use, 'is_lock:', is_lock);

      if (is_lock) return { ok: false, reason: 'lock' };
      if (!is_use) return { ok: false, reason: 'use' };

      return { ok: true, reason: null };
    }

    // 토스트 메시지 표시
    function showToast(msg='준비중입니다', ms=2000){
      const el = document.getElementById('toast');
      el.querySelector('.box').textContent = msg;
      el.classList.add('show');
      clearTimeout(showToast.tid);
      showToast.tid = setTimeout(() => el.classList.remove('show'), ms);
    }

    // 현재 페이지가 /game 인지 여부
    const isGamePage = window.location.pathname.startsWith('/game') || window.location.pathname.includes('game.html');
    
    // 쿼리 파라미터에서 game_id 추출
    let GAME_ID = null;
    if (isGamePage) {
      const params = new URLSearchParams(window.location.search);
      const idParam = params.get('game') || params.get('game_id');
      if (idParam) {
        // 'game_1' 형식이면 숫자만 추출
        const match = idParam.match(/^game_(\d+)$/i);
        GAME_ID = match ? parseInt(match[1], 10) : parseInt(idParam, 10);
      } else if (CURRENT_GAME?.id) {
        GAME_ID = CURRENT_GAME.id;
      }
    }
    
    // HUD / 내레이션 영역 DOM
    const hudEl = document.getElementById('game-hud');
    const narrationEl = document.getElementById('game-narration');

    // 백엔드 LLM 호출
    async function askLLM(message, mode='trpg', choices=0){
      try {
      const token = getToken();
      const headers = { 'Content-Type': 'application/json' };
      
      // 로그인 토큰이 있으면 헤더에 추가
      if (token) {
        headers['Authorization'] = `Bearer ${token}`;
      }
      
      // 게임 페이지면 /v1/games/{id}/turn, 아니면 /v1/chat/
      const API_URL = isGamePage && GAME_ID
        ? `${API_BASE_URL}/v1/games/${GAME_ID}/turn`
        : `${API_BASE_URL}/v1/chat/`;
      
      // 게임 턴 API는 {user_message: ...} 형식, /chat은 {message: ...} 형식
      const payload = isGamePage && GAME_ID
        ? { user_message: message }
        : {
            message, mode,
            model:'trpg-gen', polish_model:'trpg-polish', choices,
            game_id: CURRENT_GAME?.id ?? null,
            game: CURRENT_GAME ? {
              id: CURRENT_GAME.id,
              title: CURRENT_GAME.title,
              scenario_summary: CURRENT_GAME.scenario_summary,
              scenario_detail: CURRENT_GAME.scenario_detail,
              tags: CURRENT_GAME.tags || [],
              world_snapshot: CURRENT_GAME.world_snapshot,
              characters: CURRENT_GAME.characters || [],
            } : null,
          };
        
        console.log('[askLLM] Request URL:', API_URL);
        console.log('[askLLM] API_BASE_URL:', API_BASE_URL);
        console.log('[askLLM] isGamePage:', isGamePage, 'GAME_ID:', GAME_ID);
        console.log('[askLLM] Payload:', payload);
        
        const r = await fetch(API_URL, {
          method: "POST",
          credentials: "include",
          headers: headers,
          body: JSON.stringify(payload),
        });
        
        console.log('[askLLM] Response status:', r.status, r.statusText);
        console.log('[askLLM] Response headers:', Object.fromEntries(r.headers.entries()));
        
        if (!r.ok) {
          const errorText = await r.text();
          console.error(`[askLLM] HTTP ${r.status} Error:`, errorText);
          throw new Error(`HTTP ${r.status}: ${errorText || 'Server error'}`);
        }
        
      const j = await r.json();
        console.log('[askLLM] Response JSON:', j);
      
      // 게임 턴 API 응답 형식 처리
      if (isGamePage && GAME_ID) {
        // === TRPG 게임 모드 응답 처리 ===
        // 백엔드 응답에서 session을 직접 사용 (중복 방지: 세션 전체 교체)
        // 플레이어 메시지는 이미 백엔드에서 turn_logs에 포함되어 있으므로
        // 로컬로 추가하지 않고 백엔드가 내려준 session을 그대로 사용
        if (j.session) {
          // 백엔드 응답의 session을 그대로 사용 (중복 방지: 세션 전체 교체)
          const prevLength = currentSession?.turn_logs?.length || 0;
          currentSession = j.session;
          const newLength = currentSession.turn_logs.length;
          console.log("[DEBUG] Using session from response, turn_logs length:", prevLength, "->", newLength);
          
          // 1) HUD 업데이트
          renderHudFromSession(currentSession);
          
          // 2) 채팅 로그 업데이트 (전체 재렌더링 - session.turn_logs만 사용, 한 번만)
          // 로컬 메시지 배열 없이 오직 session.turn_logs만 렌더링
          renderChatLogsFromSession(currentSession);
          
          // 3) 내레이션 업데이트
          if (narrationEl) {
            const lastNarration = currentSession.turn_logs
              .filter(log => log.speaker_type === 'narration')
              .pop();
            if (lastNarration) {
              narrationEl.textContent = lastNarration.text;
            }
          }
        } else {
          // 폴백: 세션을 다시 로드 (하지만 중복 방지를 위해 한 번만)
          console.warn('[askLLM] j.session not found, loading from API');
          const sessionData = await loadSession(GAME_ID);
          if (sessionData && sessionData.session) {
            const prevLength = currentSession?.turn_logs?.length || 0;
            currentSession = sessionData.session;
            const newLength = currentSession.turn_logs.length;
            console.log("[DEBUG] Loaded session from API, turn_logs length:", prevLength, "->", newLength);
            renderHudFromSession(currentSession);
            renderChatLogsFromSession(currentSession);
            if (narrationEl) {
              const lastNarration = currentSession.turn_logs
                .filter(log => log.speaker_type === 'narration')
                .pop();
              if (lastNarration) {
                narrationEl.textContent = lastNarration.text;
              }
            }
          } else {
            console.warn('[askLLM] Session data not available');
          }
        }
        
        return (j.narration || '').trim();
      } else {
        // === 기존 세계관 / 일반 채팅 응답 처리 ===
        const answer = j?.answer || j?.message || j?.content || (typeof j === 'string' ? j : '');
        if (answer) {
          addBot(answer);
        }
        return answer;
      }
      } catch(e) {
        console.error('[askLLM] Error:', e);
        console.error('[askLLM] Error stack:', e.stack);
        const errorMsg = e.message || String(e);
        return `(오류 발생) ${errorMsg}`;
      }
    }

    // 세션 상태 관리
    let currentSession = null;

    // 세션 로딩
    async function loadSession(gameId) {
      try {
        const res = await fetch(`${API_BASE_URL}/v1/games/${gameId}/session`, {
          method: 'GET',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
        });
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        const data = await res.json();
        return data;
      } catch (error) {
        console.error('[loadSession] Error:', error);
        return null;
      }
    }

    // 세션 기반 HUD 렌더링
    function renderHudFromSession(session) {
      if (!session || !hudEl) return;
      
      const player = session.player;
      const npcs = session.npcs || [];
      
      hudEl.innerHTML = `
        <div class="game-hud-section">
          <div class="game-hud-title">플레이어</div>
          <div>HP: ${player.hp} / ${player.hp_max}</div>
          <div>MP: ${player.mp} / ${player.mp_max}</div>
          <div>Gold: ${player.gold}</div>
        </div>
        <div class="game-hud-section">
          <div class="game-hud-title">동료 / NPC</div>
          ${
            npcs.length === 0
              ? '<div class="game-hud-char">아직 동료가 없습니다.</div>'
              : npcs
                  .map((npc) => {
                    return `
                      <div class="game-hud-char">
                        <span class="game-hud-char-name">${escapeHtml(npc.name)}</span>
                        <span class="game-hud-char-stats">
                          <span>HP ${npc.hp}/${npc.hp_max}</span>
                          <span>MP ${npc.mp}/${npc.mp_max}</span>
                        </span>
                      </div>
                    `;
                  })
                  .join('')
          }
        </div>
      `;
      hudEl.style.display = 'flex';
      hudEl.style.gap = '24px';
      hudEl.style.color = '#f5f5f5';
    }

    // 캐릭터 맵 생성 (characters_info 기반 - id와 name 둘 다로 매핑)
    // 반드시 session.characters_info만 사용 (game.characters_info 제거)
    function buildCharacterMaps(session) {
      const infoList = session?.characters_info || [];
      
      // id로 매핑하는 맵
      const byId = new Map();
      // name으로 매핑하는 맵
      const byName = new Map();
      
      // session.characters_info만 사용
      infoList.forEach((c) => {
        const snap = c.snapshot;
        if (!snap) return;
        
        const charId = Number(c.char_ref_id);
        if (!Number.isNaN(charId) && charId) {
          byId.set(charId, snap);
        }
        if (snap.name) {
          byName.set(snap.name.trim(), snap);
        }
      });
      
      console.log("[DEBUG] characterMaps", { 
        infoList,
        byId: Array.from(byId.entries()),
        byName: Array.from(byName.entries())
      });
      
      return { byId, byName };
    }

    // 아바타 URL 계산 함수 (페이지 레벨에서 계산)
    function getAvatarForLog(log, characterMaps, session) {
      const { byId, byName } = characterMaps;
      
      let rawUrl = null;
      let name = log.speaker_name || undefined;
      
      if (log.speaker_type === 'npc' || log.speaker_type === 'monster') {
        const id = log.speaker_id != null ? Number(log.speaker_id) : NaN;
        let snapshot = null;
        
        // 1차: speaker_id로 찾기
        if (!Number.isNaN(id)) {
          snapshot = byId.get(id);
        }
        
        // 2차: speaker_name으로 찾기
        if (!snapshot && name) {
          snapshot = byName.get(name.trim());
        }
        
        // 3차: 세션의 npcs에서 찾기 (fallback)
        if (!snapshot && log.speaker_id != null) {
          const npc = session.npcs?.find(n => n.id === Number(log.speaker_id));
          if (npc) {
            snapshot = { image_url: npc.image_url, name: npc.name };
          }
        }
        
        if (snapshot) {
          rawUrl = snapshot.image_url || null;
          if (!name) name = snapshot.name || 'NPC';
        } else {
          if (!name) name = 'NPC';
        }
      } else if (log.speaker_type === 'player') {
        rawUrl = null; // 플레이어는 아바타 없음
        if (!name) name = '플레이어';
      }
      
      // 상대 경로를 풀 URL로 변환 (resolveAssetUrl 사용)
      const avatarUrl = rawUrl ? resolveAssetUrl(rawUrl) : resolveAssetUrl('/assets/img/placeholder.jpg');
      
      console.log("[DEBUG] avatarForLog", { 
        log: { speaker_type: log.speaker_type, speaker_id: log.speaker_id, speaker_name: log.speaker_name },
        rawUrl,
        avatarUrl,
        name
      });
      
      return { avatarUrl, name };
    }

    // 세션 기반 채팅 로그 렌더링 (오직 session.turn_logs만 사용)
    function renderChatLogsFromSession(session) {
      if (!session) {
        console.warn("[DEBUG] renderChatLogsFromSession: no session");
        return;
      }
      
      const chatEl = document.getElementById('chat');
      if (!chatEl) {
        console.warn("[DEBUG] renderChatLogsFromSession: chat element not found");
        return;
      }
      
      // 기존 로그 제거 (중복 방지) - 항상 완전히 비우기
      const beforeLength = chatEl.children.length;
      chatEl.innerHTML = '';
      console.log("[DEBUG] renderChatLogsFromSession: cleared", beforeLength, "existing messages, rendering", (session.turn_logs || []).length, "logs");
      
      // 선택지 버튼 영역도 비우기 (중복 방지) - 항상 완전히 비우기
      const actionsEl = document.getElementById('game-turn-actions');
      if (actionsEl) {
        const beforeActions = actionsEl.children.length;
        actionsEl.innerHTML = '';
        console.log("[DEBUG] renderChatLogsFromSession: cleared", beforeActions, "existing action buttons");
      }
      
      // 캐릭터 맵 생성 (id와 name 둘 다로 매핑) - session만 사용
      const characterMaps = buildCharacterMaps(session);
      
      // 세션의 turn_logs를 렌더링 (오직 session.turn_logs만 사용)
      const logs = session.turn_logs || [];
      console.log("[DEBUG] turn_logs length", logs.length);
      
      logs.forEach((log) => {
        if (log.speaker_type === 'narration') {
          // 내레이션은 별도 처리하지 않음 (노란 영역에만 표시)
          return;
        }
        
        const isPlayer = log.speaker_type === 'player';
        const row = document.createElement('div');
        row.className = `msg ${isPlayer ? 'me' : ''}`;
        
        // 페이지 레벨에서 아바타 URL 계산
        const { avatarUrl, name: displayName } = getAvatarForLog(log, characterMaps, session);
        
        // 이름 레이블 생성
        const nameLabel = displayName ? `<strong>${escapeHtml(displayName)}</strong>: ` : '';
        
        // 플레이어는 아바타 없이
        if (isPlayer) {
          row.innerHTML = `<div class="bubble">${renderMessageText(log.text)}</div>`;
        } else {
          // NPC/Monster는 아바타와 함께 (이미 풀 URL로 변환된 avatarUrl 사용)
          row.innerHTML = `<img class="avatar" src="${avatarUrl}" alt="${displayName || 'NPC'}"/><div class="bubble">${nameLabel}${renderMessageText(log.text)}</div>`;
        }
        
        chatEl.appendChild(row);
      });
      
      // 마지막 턴의 선택지 처리 (한 번만, 중복 방지)
      if (logs.length > 0 && actionsEl) {
        const lastLog = logs[logs.length - 1];
        const choices = lastLog?.choices || lastLog?.meta?.choices || [];
        console.log("[DEBUG] Rendering choices for last log:", choices.length, "choices");
        if (choices.length > 0) {
          // 중복 방지: 기존 버튼 제거 후 추가
          actionsEl.innerHTML = '';
          choices.forEach((choice, index) => {
            const btn = document.createElement('button');
            btn.textContent = choice.text || choice;
            btn.onclick = () => {
              const choiceText = choice.text || choice;
              const ta = document.getElementById('ta');
              if (ta) {
                ta.value = choiceText;
                const sendBtn = document.getElementById('send');
                if (sendBtn) sendBtn.click();
              }
            };
            actionsEl.appendChild(btn);
          });
        }
      }
      
      // 자동 스크롤 (하단 마커로) - 약간의 지연을 두어 DOM 업데이트 완료 후 실행
      // window.scrollTo는 사용하지 않고, 채팅 컨테이너 내부에서만 스크롤
      setTimeout(() => {
        const bottomMarker = document.getElementById('chat-bottom-marker');
        const chatContainer = chatEl.closest('.game-chat-log');
        if (bottomMarker && chatContainer) {
          // 채팅 로그 컨테이너 내부에서만 스크롤
          bottomMarker.scrollIntoView({ behavior: 'smooth', block: 'end' });
        } else if (chatEl) {
          // 폴백: 직접 스크롤
          chatEl.scrollTop = chatEl.scrollHeight;
        }
      }, 100);
    }

    // 메시지 텍스트 렌더링 (*대사* → 기울임체)
    function renderMessageText(text) {
      if (!text) return '';
      
      // *텍스트* 패턴 찾기
      const actionPattern = /^\*(.+?)\*$/;
      const match = text.match(actionPattern);
      
      if (match && match[1]) {
        return `<em>${escapeHtml(match[1])}</em>`;
      }
      
      return escapeHtml(text);
    }

    // 초기화
    document.addEventListener('DOMContentLoaded', async ()=>{
      console.log("[DEBUG] Rendering game chat template - apps/web-html/game.html");
      
      // 뒤로가기
      document.getElementById('backBtn').onclick=()=>{ if(history.length>1) history.back(); else location.href='/home.html'; };

      // URL → 게임 id 정규화
      const raw  = qs('game') || qs('game_id') || null;
      const norm = normalizeGameId(raw) || 1;
      dbg('[param] raw='+raw+' norm='+norm);

      // 상세 API 호출
      let game=null;
      try { game = await fetchGame(norm); }
      catch(e){ dbg('[error] '+e.message); game = {id:norm, title:'미확인 게임', background_image_path:'/assets/img/placeholder.jpg', scenario_summary:'정보 없음'}; }
      CURRENT_GAME = game;
      paintGame(game);
      
      // 세션 로딩 (초기 로드만 - gameId만 의존성, session/turn_logs는 의존성에 넣지 않음)
      const sessionData = await loadSession(norm);
      if (sessionData && sessionData.session) {
        currentSession = sessionData.session;
        console.log("[DEBUG] Initial session load, turn_logs length:", currentSession.turn_logs.length);
        
        // HUD 렌더링
        renderHudFromSession(currentSession);
        
        // 채팅 로그 렌더링 (session.turn_logs만 사용 - 한 번만)
        renderChatLogsFromSession(currentSession);
        
        // 내레이션 영역 업데이트
        if (narrationEl && currentSession.turn_logs.length > 0) {
          const lastNarration = currentSession.turn_logs
            .filter(log => log.speaker_type === 'narration')
            .pop();
          if (lastNarration) {
            narrationEl.textContent = lastNarration.text;
          }
        }
      } else {
        // 초기 내레이션 영역에 게임 소개 텍스트 설정
        if (narrationEl) {
          const initialText = game.scenario_summary || game.scenario_detail || game.title || '게임을 시작하세요.';
          narrationEl.textContent = initialText;
        }
      }

      // 게임은 인사말 없이 자유롭게 채팅 시작

      // 입력 동작
      const ta=document.getElementById('ta'), btn=document.getElementById('send');
      
      // 비로그인 상태에서 입력/전송 시도 시 계정 상태 체크
      async function checkLoginAndSend(){
        const status = await checkAccountStatus();

        if (!status.ok) {
          if (status.reason === 'login') {
            showToast('로그인이 필요합니다.', 2000);
          } else if (status.reason === 'lock') {
            showToast('현재 계정이 차단된 상태입니다.', 2000);
          } else if (status.reason === 'use') {
            showToast('현재 사용이 불가한 상태입니다.', 2000);
          } else {
            showToast('계정 상태를 확인할 수 없습니다.', 2000);
          }
          ta.blur();
          return false;
        }
        return true;
      }

      async function send(){
        // 로그인 체크
        if (!(await checkLoginAndSend())) return;
        
        const v=ta.value.trim(); if(!v)return;
        
        // 플레이어 메시지는 세션에 포함되므로 여기서 추가하지 않음
        // (백엔드에서 turn_logs에 추가되고, askLLM에서 세션 재로드 시 렌더링됨)
        
        ta.value=''; btn.disabled=true;
        
        console.log('[send] Starting API call with message:', v);
        console.log('[send] API_BASE_URL:', API_BASE_URL);
        console.log('[send] isGamePage:', isGamePage, 'GAME_ID:', GAME_ID);
        
        try{ 
          const ans=await askLLM(v,'trpg');
          console.log('[send] Received answer:', ans);
          // 게임 페이지가 아닐 때만 addBot 호출 (게임 페이지는 askLLM 내부에서 처리)
          if (!isGamePage && ans) {
            addBot(ans||'(응답이 비어있습니다)');
          }
        }
        catch(e){ 
          console.error('[send] Error caught:', e);
          if (isGamePage && GAME_ID) {
            // 에러 메시지만 추가 (세션 재렌더링은 하지 않음)
            const chatEl = document.getElementById('chat');
            if (chatEl) {
              const row = document.createElement('div');
              row.className = 'msg';
              row.innerHTML = `<div class="bubble">서버 오류: ${escapeHtml(e.message)}</div>`;
              chatEl.appendChild(row);
              const bottomMarker = document.getElementById('chat-bottom-marker');
              if (bottomMarker) {
                bottomMarker.scrollIntoView({ behavior: 'smooth', block: 'end' });
              } else {
                chatEl.scrollTop = chatEl.scrollHeight;
              }
            }
          } else {
            addBot('서버 오류: '+e.message);
          }
        }
        finally{ 
          btn.disabled=false; 
          ta.focus(); 
        }
      }
      
      // 입력 필드 포커스 시 계정 상태 체크
      ta.addEventListener('focus', async (ev) => {
        const status = await checkAccountStatus();
        if (!status.ok) {
          ev.preventDefault();
          ta.blur();

          if (status.reason === 'login') {
            showToast('로그인이 필요합니다.', 2000);
          } else if (status.reason === 'lock') {
            showToast('현재 계정이 차단된 상태입니다.', 2000);
          } else if (status.reason === 'use') {
            showToast('현재 사용이 불가한 상태입니다.', 2000);
          } else {
            showToast('계정 상태를 확인할 수 없습니다.', 2000);
          }
        }
      });

      // 클릭 시도 시 계정 상태 체크
      ta.addEventListener('click', async (ev) => {
        const status = await checkAccountStatus();
        if (!status.ok) {
          ev.preventDefault();
          ta.blur();

          if (status.reason === 'login') {
            showToast('로그인이 필요합니다.', 2000);
          } else if (status.reason === 'lock') {
            showToast('현재 계정이 차단된 상태입니다.', 2000);
          } else if (status.reason === 'use') {
            showToast('현재 사용이 불가한 상태입니다.', 2000);
          } else {
            showToast('계정 상태를 확인할 수 없습니다.', 2000);
          }
        }
      });

      btn.onclick=send;
      ta.addEventListener('keydown', ev=>{ 
        if (ev.key==='Enter' && !ev.shiftKey){ 
          ev.preventDefault(); 
          send(); 
        }
      });
    });
  </script>
</body>
</html>



