<!-- ========================================
     apps/web-html/game.html — 게임 상세(채팅) 화면
     - URL ?game=1 또는 ?game_id=1 지원
     - /v1/games/:id 단건 호출해서 렌더
     - 이미지 경로 보정(resolvePath)로 /assets/game/… 보장
     - 게임 채팅 시작
     ======================================== -->
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Game Chat • TRPG</title>
  <script src="/js/config.js"></script>
  <script src="/js/assets.js"></script>
  <script>
    // 전역 API 엔드포인트 설정 (어디서든 window.API_BASE_URL로 접근)
    window.API_BASE_URL = 'https://api.arcanaverse.ai';
    window.API_BASE = 'https://api.arcanaverse.ai';
    
    // 게임 ID 주입 (쿼리 파라미터에서 추출)
    (function() {
      const params = new URLSearchParams(window.location.search);
      const gameId = params.get('game') || params.get('game_id');
      if (gameId) {
        // 'game_1' 형식이면 숫자만 추출
        const match = gameId.match(/^game_(\d+)$/i);
        window.GAME_ID = match ? parseInt(match[1], 10) : parseInt(gameId, 10);
      }
    })();
  </script>
  <script src="/js/game_turn.js"></script>
  <style>
    :root { color-scheme: dark; } /* 다크 테마 힌트 */
    body { margin:0; background:#0b0f14; color:#e5e7eb; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,'Apple SD Gothic Neo','Malgun Gothic',sans-serif; }
    .topbar-wrap { display:flex; justify-content:center; border-bottom:1px solid #1b2430; background:#0e141c; position:sticky; top:0; z-index:20; }
    .topbar { width:100%; max-width:980px; display:flex; align-items:center; gap:10px; padding:10px 14px; }
    .back { display:inline-flex; align-items:center; justify-content:center; width:36px; height:36px; border-radius:10px; border:1px solid #223042; background:#0f172a; color:#cbd5e1; cursor:pointer; }
    .title { font-weight:700; font-size:15px; color:#f1f5f9; }
    .hero { position:relative; margin:18px auto; max-width:980px; }
    .hero img { width:100%; border-radius:14px; border:1px solid #1f2937; box-shadow:0 10px 28px rgba(0,0,0,.35); display:block; }
    .panel { max-width:980px; margin:10px auto 18px; background:#0f172a; border:1px solid #1e293b; border-radius:12px; padding:12px 14px; }
    .chips { margin-top:6px; display:flex; gap:8px; flex-wrap:wrap; }
    .chip { padding:3px 8px; font-size:11px; border-radius:999px; border:1px solid #334155; color:#a5b4fc; background:#0b1220; }
    .hint { font-size:12px; color:#9ca3af; margin-top:6px; }
    /* game-hud-box는 game-hero-stats로 대체되었으므로 제거 */
    /* 기존 스타일은 game-hero-stats에 통합됨 */
    .game-hud-section {
      min-width:180px;
    }
    .game-hud-title {
      font-weight:600;
      margin-bottom:4px;
      opacity:0.7;
    }
    .game-hud-char {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-top:4px;
      font-size:12px;
    }
    .game-hud-char-name {
      font-weight:600;
      margin-right:8px;
    }
    .game-hud-char-stats {
      display:flex;
      gap:8px;
      opacity:0.85;
    }
    /* 전체 게임 페이지: 상단 고정 + 하단 스크롤을 위한 기본 레이아웃 */
    .game-page {
      display: flex;
      flex-direction: column;
      height: 100vh;          /* 전체 화면 꽉 채우기 */
    }
    /* 상단 히어로 영역: 네비게이션 바로부터 살짝 아래에 sticky */
    .game-hero {
      position: sticky;
      top: 64px;              /* 상단 네비게이션 높이에 맞춰 조정 (필요시 56~80px 사이로 조절) */
      z-index: 10;
      margin-bottom: 16px;
    }
    /* 이미지 + 시나리오 카드 컨테이너 (기존 카드 스타일 유지 + relative 추가) */
    .game-hero-card {
      position: relative;     /* 내부에 absolute 오버레이를 두기 위해 필요 */
      overflow: hidden;
      border-radius: 16px;
    }
    /* ▶ 여기서 핵심: 스탯 박스를 이미지 위에 겹쳐 올림 */
    .game-hero-stats {
      position: absolute;
      left: 16px;
      right: 16px;
      bottom: 16px;           /* 이미지 하단에서 조금 띄워서 붙이기 */
      z-index: 20;
      padding: 12px 16px;
      border-radius: 12px;
      /* 반투명 HUD 느낌 (프로젝트 색상 토큰 있으면 거기에 맞게 바꿔줘) */
      background: rgba(5, 7, 14, 0.85);
      backdrop-filter: blur(6px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      font-size: 0.9rem;
    }
    /* 스탯 테이블이 너무 붙어보이지 않게 약간의 여백 */
    .game-hero-stats table,
    .game-hero-stats .stats-row {
      width: 100%;
    }
    /* 하단: 채팅 영역 전체 */
    .game-body {
      flex: 1;                /* 남은 세로 공간 전부 차지 */
      display: flex;
      flex-direction: column;
      min-height: 0;          /* flex 컨테이너 안에서 overflow가 제대로 작동하게 */
    }
    /* 채팅 로그는 스크롤 영역 */
    .game-chat-log {
      flex: 1;
      overflow-y: auto;
      padding-bottom: 12px;
    }
    /* 채팅 입력 영역은 화면 하단에 고정되듯이 항상 보이게 */
    .game-chat-input {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }
    /* 기존 채팅 스타일 유지 */
    #chat, #chat-log {
      max-width:980px;
      margin:0 auto;
      padding:0 4px;
    }
    .msg { display:flex; align-items:flex-start; gap:10px; margin:14px 0; animation:fadeInUp .35s ease; }
    .msg.me { flex-direction:row-reverse; }
    .avatar { width:42px; height:42px; border-radius:50%; object-fit:cover; box-shadow:0 0 6px rgba(0,0,0,.4); }
    .bubble { background:#111827; border:1px solid #1f2937; padding:10px 14px; border-radius:14px; white-space:pre-wrap; line-height:1.6; max-width:70%; }
    .me .bubble { background:rgba(63,131,248,0.25); border-color:#334155; }
    .inputBar { position:fixed; left:0; right:0; bottom:0; border-top:1px solid #1b2430; background:#0e141c; padding:12px; }
    .inputIn { max-width:980px; margin:0 auto; display:flex; gap:8px; }
    textarea { flex:1; resize:none; background:#0b1220; border:1px solid #1f2937; border-radius:10px; color:#e5e7eb; padding:10px 12px; min-height:44px; }
    button { padding:0 14px; border-radius:10px; border:1px solid #334155; background:#111827; color:#c7d2fe; height:44px; }
    button[disabled]{ opacity:.6; cursor:not-allowed; }
    .bg { position:fixed; inset:0; background-position:center; background-size:cover; opacity:.4; filter:blur(1.5px) brightness(0.9); z-index:-1; transition:filter .5s ease, opacity .5s ease; }
    .debug { max-width:980px; margin:6px auto 0; font-size:12px; color:#93c5fd; opacity:.9; white-space:pre-wrap; }
    /* toast layer */
    .toast { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; opacity:0; transition:opacity .18s ease; z-index:50; }
    .toast.show { opacity:1; }
    .toast .box { pointer-events:auto; min-width:200px; max-width:80vw; background:#0f172a; border:1px solid #1f2937; color:#e5e7eb; padding:14px 18px; border-radius:12px; box-shadow:0 12px 32px rgba(0,0,0,.45); text-align:center; }
    @keyframes fadeInUp { from { opacity:0; transform:translateY(12px); } to { opacity:1; transform:translateY(0); } }
  </style>
</head>
<body>
  <div class="bg" id="bg"></div> <!-- 흐림 배경 -->

  <div class="topbar-wrap">
    <div class="topbar">
      <button id="backBtn" class="back" title="뒤로 가기">←</button> <!-- 뒤로가기 -->
      <div class="title" id="title">로딩 중…</div>                   <!-- 게임 이름 -->
    </div>
  </div>

  <div id="game-page" class="game-page">
    <!-- 상단: 이미지 + 시나리오 + HUD(스탯) -->
    <section class="game-hero">
      <div class="game-hero-card">
        <div class="hero"><img id="hero" alt="cover" src="/assets/img/placeholder.jpg" /></div> <!-- 히어로 이미지 -->
        <div class="debug" id="dbg"></div> <!-- 디버그 로그(요청/이미지 경로) -->

        <div class="panel" id="about">
          <div style="font-weight:700; margin-bottom:6px;">소개</div>
          <div id="game-narration" style="opacity:.9"></div> <!-- 내레이션 영역 (기존 bio 영역 재사용) -->
          <div class="chips">
            <span class="chip">TRPG</span>
            <span class="chip" id="chip-name">게임</span>
          </div>
          <div class="hint">Tip: 메세지를 보내면 게임 턴이 진행됩니다.</div>
        </div>

        <!-- ⬇️ 스탯 박스를 이미지 위에 오버레이로 배치 -->
        <div id="game-hud" class="game-hero-stats">
          <div class="game-hud-section">
            <div class="game-hud-title">상태</div>
            <div class="game-hud-body">게임을 시작하면 상태가 표시됩니다.</div>
          </div>
        </div>
      </div>
    </section>

    <!-- 하단: 채팅 로그 + 입력창 -->
    <section class="game-body">
      <div class="game-chat-log">
        <div class="chat" id="chat"></div> <!-- 채팅 로그 -->
        <div class="chat" id="chat-log" style="display:none;"></div> <!-- 턴 시스템용 채팅 로그 -->
      </div>
      <form class="game-chat-input">
        <!-- 입력창은 기존 inputBar 사용 -->
      </form>
    </section>
  </div>

  <div class="inputBar">
    <div class="inputIn">
      <textarea id="ta" placeholder="메시지 입력…"></textarea>  <!-- 입력창 (기존) -->
      <textarea id="user-input" placeholder="메시지 입력…" style="display:none;"></textarea>  <!-- 턴 시스템용 입력창 -->
      <button id="send">보내기</button>                         <!-- 전송 (기존) -->
      <button id="send-btn" style="display:none;">보내기</button>  <!-- 턴 시스템용 전송 버튼 -->
    </div>
  </div>

  <!-- Toast Layer -->
  <div id="toast" class="toast" aria-live="polite" aria-atomic="true">
    <div class="box">준비중입니다</div>
  </div>

  <script>
    // API_BASE_URL은 이미 위쪽에서 window.API_BASE_URL로 설정됨

    // --- 전역/유틸 -------------------------------------------------------------
    let CURRENT_GAME = null;  // 현재 게임
    const FALLBACK_SVG = 'data:image/svg+xml;utf8,' + encodeURIComponent(
      `<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="675"><rect width="100%" height="100%" fill="#0e141c"/><text x="50%" y="50%" fill="#94a3b8" font-size="48" font-family="sans-serif" text-anchor="middle" dominant-baseline="middle">No Image</text></svg>`
    );
    const dbg = (m) => { 
      const el=document.getElementById('dbg'); 
      // el.textContent = (el.textContent?el.textContent+"\n":"") + m; 
      // console.log(m); 
    };

    function qs(k){ return new URL(location.href).searchParams.get(k); } // 쿼리 파서

    // 'game_1' → 1 / '1' → 1
    function normalizeGameId(v){
      if(!v) return null;
      if(/^game_\d{1,6}$/i.test(v)) return parseInt(v.split('_')[1],10);
      if(/^\d+$/.test(v)) return parseInt(v,10);
      return v;
    }

    // 이미지 경로 보정 → 항상 /assets/game/... 또는 /assets/img/... 로
    function resolvePath(p){
      if (!p) return '/assets/img/placeholder.jpg';
      if (/^https?:\/\//i.test(p)) return p;
      p = String(p).replace(/\\/g, '/').trim();
      if (p.startsWith('/')) return p;
      if (p.startsWith('assets/')) return '/' + p;

      if (p.includes('/game/') || p.startsWith('game/') || p.startsWith('assets/game/')) {
        if (p.startsWith('assets/')) return '/' + p;
        if (p.startsWith('game/'))   return '/assets/' + p;
        return '/assets/game/' + p.replace(/^\/+/, '');
      }
      // 세계관 이미지 처리
      if (p.includes('/world/') || p.startsWith('world/') || p.startsWith('assets/world/')) {
        if (p.startsWith('assets/')) return '/' + p;
        if (p.startsWith('world/'))   return '/assets/' + p;
        return '/assets/world/' + p.replace(/^\/+/, '');
      }
      return '/assets/img/' + p.replace(/^\/+/, '');
    }

    // 안전한 hero 이미지 로더(404 시 SVG로 대체)
    function safeSetHero(imgUrl){
      const hero=document.getElementById('hero');
      hero.onerror=()=>{ dbg('[hero 404] '+imgUrl); hero.src=FALLBACK_SVG; };
      hero.onload =()=>{ dbg('[hero 200] '+imgUrl); };
      hero.src=imgUrl||'/assets/img/placeholder.jpg';
      dbg('[hero set] '+hero.src);
    }

    // 단일 게임 API 호출 (상세)
    async function fetchGame(id){
      dbg('[fetch] /v1/games/'+id);
      const r = await fetch(`${API_BASE_URL}/v1/games/${id}`, {
        method: "GET",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        cache: 'no-store'
      });
      dbg('[fetch status] '+r.status);
      if(!r.ok) throw new Error('게임 불러오기 실패: HTTP '+r.status);
      const j = await r.json();
      dbg('[fetch image] '+j.background_image_path);
      return j;
    }

    // 상단/배경/칩 렌더
    function paintGame(game){
      document.getElementById('title').textContent=game.title||game.id;
      document.getElementById('chip-name').textContent=game.title||'게임';
      const bioText = game.scenario_summary || game.scenario_detail || game.title || '';
      // bio 대신 game-narration 사용
      const narrationEl = document.getElementById('game-narration');
      if (narrationEl) {
        narrationEl.textContent = bioText.toString();
      }

      // 게임 배경 이미지: 백엔드에서 R2 public URL로 변환된 필드 우선 사용
      const img = game.image || 
                 game.background_image_url || 
                 (game.world_snapshot && game.world_snapshot.image_url) || 
                 '/assets/img/placeholder.jpg';
      dbg('[resolved img] '+img);
      safeSetHero(img);                                         // 히어로 이미지
      document.getElementById('bg').style.backgroundImage=`url("${img}")`; // 흐림 배경

      const wrap=document.querySelector('.chips');              // tags 칩
      wrap.querySelectorAll('.chip.extra').forEach(n=>n.remove());
      // tags 배열 처리
      if(game.tags && Array.isArray(game.tags)){
        game.tags.forEach(tag=>{
          if(tag){ const s=document.createElement('span'); s.className='chip extra'; s.textContent=tag; wrap.appendChild(s); }
        });
      }
    }

    // 채팅 메시지 DOM 유틸
    function escapeHtml(s){ 
      return String(s||'').replace(
        /[&<>"']/g,
        c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])
      );
    }
    function addUser(text){ const chat=document.getElementById('chat'); const row=document.createElement('div'); row.className='msg me'; row.innerHTML=`<div class="bubble">${escapeHtml(text)}</div>`; chat.appendChild(row); chat.scrollTop=chat.scrollHeight; }
    function addBot(text, name=null){  
      const chat=document.getElementById('chat'); 
      const row=document.createElement('div'); 
      row.className='msg'; 
      // 게임 배경 이미지: 백엔드에서 R2 public URL로 변환된 필드 우선 사용
      const img = CURRENT_GAME?.image || 
                 CURRENT_GAME?.background_image_url || 
                 (CURRENT_GAME?.world_snapshot && CURRENT_GAME.world_snapshot.image_url) || 
                 '/assets/img/placeholder.jpg';
      const nameLabel = name ? `<strong>${escapeHtml(name)}</strong>: ` : '';
      row.innerHTML=`<img class="avatar" src="${img}" alt="bot"/><div class="bubble">${nameLabel}${escapeHtml(text)}</div>`; 
      chat.appendChild(row); 
      chat.scrollTop=chat.scrollHeight; 
    }
    
    function renderGameHud(userInfo, charactersInfo) {
      if (!hudEl) return;
      
      const attrs = (userInfo && userInfo.attributes) || {};
      const hp = attrs.hp || {};
      const mp = attrs.mp || {};
      const items = (userInfo && userInfo.items) || {};
      const gold = items.gold ?? 0;
      const chars = Array.isArray(charactersInfo) ? charactersInfo : [];
      
      hudEl.innerHTML = `
        <div class="game-hud-section">
          <div class="game-hud-title">플레이어</div>
          <div>HP: ${hp.current ?? 0} / ${hp.max ?? 0}</div>
          <div>MP: ${mp.current ?? 0} / ${mp.max ?? 0}</div>
          <div>Gold: ${gold}</div>
        </div>
        <div class="game-hud-section">
          <div class="game-hud-title">동료 / NPC</div>
          ${
            chars.length === 0
              ? '<div class="game-hud-char">아직 동료가 없습니다.</div>'
              : chars
                  .map((c) => {
                    const snap = c.snapshot || {};
                    const name = snap.name || '???';
                    const a = snap.attributes || {};
                    const chp = a.hp || {};
                    const cmp = a.mp || {};
                    return `
                      <div class="game-hud-char">
                        <span class="game-hud-char-name">${escapeHtml(name)}</span>
                        <span class="game-hud-char-stats">
                          <span>HP ${chp.current ?? 0}/${chp.max ?? 0}</span>
                          <span>MP ${cmp.current ?? 0}/${cmp.max ?? 0}</span>
                        </span>
                      </div>
                    `;
                  })
                  .join('')
          }
        </div>
      `;
      // game-hero-stats는 flex 레이아웃 유지
      hudEl.style.display = 'flex';
      hudEl.style.gap = '24px';
      hudEl.style.color = '#f5f5f5';
    }

    // 토큰 관리
    const TOKEN_KEY = 'access_token';
    const USER_INFO_KEY = 'user_info_v2';

    function getToken() { return localStorage.getItem(TOKEN_KEY); }
    function isLoggedIn() { return !!getToken(); }

    async function getUserInfo() {
      const userInfoV2 = localStorage.getItem(USER_INFO_KEY);
      if (!userInfoV2) {
        return null;
      }

      try {
        const res = await fetch(`${API_BASE_URL}/v1/auth/validate-session`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: userInfoV2 }),
          credentials: "include",
        });

        if (res.ok) {
          return await res.json();
        }
        return null;
      } catch (err) {
        console.error('Failed to get user info:', err);
        return null;
      }
    }

    /**
     * 계정 상태 체크
     * - ok: true 면 채팅 가능
     * - ok: false 이면 reason 으로 상태 구분
     *   - 'login': 로그인 필요
     *   - 'lock': 계정 차단
     *   - 'use': 사용 불가
     */
    async function checkAccountStatus() {
      const token = getToken();
      const info  = await getUserInfo();

      console.log('[ACCOUNT] token:', !!token, 'info:', info);

      if (!token) return { ok: false, reason: 'login' };

      if (!info)  return { ok: false, reason: 'login' };

      const is_use = info.is_use || false;
      const is_lock = info.is_lock || false;

      console.log('[ACCOUNT] is_use:', is_use, 'is_lock:', is_lock);

      if (is_lock) return { ok: false, reason: 'lock' };
      if (!is_use) return { ok: false, reason: 'use' };

      return { ok: true, reason: null };
    }

    // 토스트 메시지 표시
    function showToast(msg='준비중입니다', ms=2000){
      const el = document.getElementById('toast');
      el.querySelector('.box').textContent = msg;
      el.classList.add('show');
      clearTimeout(showToast.tid);
      showToast.tid = setTimeout(() => el.classList.remove('show'), ms);
    }

    // 현재 페이지가 /game 인지 여부
    const isGamePage = window.location.pathname.startsWith('/game') || window.location.pathname.includes('game.html');
    
    // 쿼리 파라미터에서 game_id 추출
    let GAME_ID = null;
    if (isGamePage) {
      const params = new URLSearchParams(window.location.search);
      const idParam = params.get('game') || params.get('game_id');
      if (idParam) {
        // 'game_1' 형식이면 숫자만 추출
        const match = idParam.match(/^game_(\d+)$/i);
        GAME_ID = match ? parseInt(match[1], 10) : parseInt(idParam, 10);
      } else if (CURRENT_GAME?.id) {
        GAME_ID = CURRENT_GAME.id;
      }
    }
    
    // HUD / 내레이션 영역 DOM
    const hudEl = document.getElementById('game-hud');
    const narrationEl = document.getElementById('game-narration');

    // 백엔드 LLM 호출
    async function askLLM(message, mode='trpg', choices=0){
      try {
      const token = getToken();
      const headers = { 'Content-Type': 'application/json' };
      
      // 로그인 토큰이 있으면 헤더에 추가
      if (token) {
        headers['Authorization'] = `Bearer ${token}`;
      }
      
      // 게임 페이지면 /v1/games/{id}/turn, 아니면 /v1/chat/
      const API_URL = isGamePage && GAME_ID
        ? `${API_BASE_URL}/v1/games/${GAME_ID}/turn`
        : `${API_BASE_URL}/v1/chat/`;
      
      // 게임 턴 API는 {user_message: ...} 형식, /chat은 {message: ...} 형식
      const payload = isGamePage && GAME_ID
        ? { user_message: message }
        : {
            message, mode,
            model:'trpg-gen', polish_model:'trpg-polish', choices,
            game_id: CURRENT_GAME?.id ?? null,
            game: CURRENT_GAME ? {
              id: CURRENT_GAME.id,
              title: CURRENT_GAME.title,
              scenario_summary: CURRENT_GAME.scenario_summary,
              scenario_detail: CURRENT_GAME.scenario_detail,
              tags: CURRENT_GAME.tags || [],
              world_snapshot: CURRENT_GAME.world_snapshot,
              characters: CURRENT_GAME.characters || [],
            } : null,
          };
        
        console.log('[askLLM] Request URL:', API_URL);
        console.log('[askLLM] API_BASE_URL:', API_BASE_URL);
        console.log('[askLLM] isGamePage:', isGamePage, 'GAME_ID:', GAME_ID);
        console.log('[askLLM] Payload:', payload);
        
        const r = await fetch(API_URL, {
          method: "POST",
          credentials: "include",
          headers: headers,
          body: JSON.stringify(payload),
        });
        
        console.log('[askLLM] Response status:', r.status, r.statusText);
        console.log('[askLLM] Response headers:', Object.fromEntries(r.headers.entries()));
        
        if (!r.ok) {
          const errorText = await r.text();
          console.error(`[askLLM] HTTP ${r.status} Error:`, errorText);
          throw new Error(`HTTP ${r.status}: ${errorText || 'Server error'}`);
        }
        
      const j = await r.json();
        console.log('[askLLM] Response JSON:', j);
      
      // 게임 턴 API 응답 형식 처리
      if (isGamePage && GAME_ID) {
        // === TRPG 게임 모드 응답 처리 ===
        const { narration, dialogues, user_info, characters_info } = j;
        
        // 1) 노란 영역: 턴 내레이션 표시
        if (narrationEl && typeof narration === 'string') {
          narrationEl.textContent = narration;
          // 제목도 "턴 내레이션"으로 변경
          const introHeader = document.querySelector('#about > div:first-child');
          if (introHeader) {
            introHeader.textContent = '턴 내레이션';
          }
        }
        
        // 2) HUD: 상태/스탯 갱신
        renderGameHud(user_info, characters_info);
        
        // 3) 채팅 로그: 대사만 출력
        if (Array.isArray(dialogues)) {
          dialogues.forEach((d) => {
            // speaker_type: "user" | "npc" | "system"
            // name: string | null
            const speakerType = d.speaker_type || 'npc';
            const name = d.name || (speakerType === 'user' ? null : 'NPC');
            const text = d.text || '';
            
            // 기존 addUser/addBot 함수를 재사용
            if (speakerType === 'user') {
              addUser(text);
            } else {
              addBot(text, name);
            }
          });
        }
        
        // narration을 반환하여 기존 코드와 호환성 유지
        return (narration || '').trim();
      } else {
        // === 기존 세계관 / 일반 채팅 응답 처리 ===
        const answer = j?.answer || j?.message || j?.content || (typeof j === 'string' ? j : '');
        if (answer) {
          addBot(answer);
        }
        return answer;
      }
      } catch(e) {
        console.error('[askLLM] Error:', e);
        console.error('[askLLM] Error stack:', e.stack);
        const errorMsg = e.message || String(e);
        return `(오류 발생) ${errorMsg}`;
      }
    }

    // 초기화
    document.addEventListener('DOMContentLoaded', async ()=>{
      // 뒤로가기
      document.getElementById('backBtn').onclick=()=>{ if(history.length>1) history.back(); else location.href='/home.html'; };

      // URL → 게임 id 정규화
      const raw  = qs('game') || qs('game_id') || null;
      const norm = normalizeGameId(raw) || 1;
      dbg('[param] raw='+raw+' norm='+norm);

      // 상세 API 호출
      let game=null;
      try { game = await fetchGame(norm); }
      catch(e){ dbg('[error] '+e.message); game = {id:norm, title:'미확인 게임', background_image_path:'/assets/img/placeholder.jpg', scenario_summary:'정보 없음'}; }
      CURRENT_GAME = game;
      paintGame(game);
      
      // 초기 내레이션 영역에 게임 소개 텍스트 설정
      if (narrationEl) {
        const initialText = game.scenario_summary || game.scenario_detail || game.title || '게임을 시작하세요.';
        narrationEl.textContent = initialText;
      }

      // 게임은 인사말 없이 자유롭게 채팅 시작

      // 입력 동작
      const ta=document.getElementById('ta'), btn=document.getElementById('send');
      
      // 비로그인 상태에서 입력/전송 시도 시 계정 상태 체크
      async function checkLoginAndSend(){
        const status = await checkAccountStatus();

        if (!status.ok) {
          if (status.reason === 'login') {
            showToast('로그인이 필요합니다.', 2000);
          } else if (status.reason === 'lock') {
            showToast('현재 계정이 차단된 상태입니다.', 2000);
          } else if (status.reason === 'use') {
            showToast('현재 사용이 불가한 상태입니다.', 2000);
          } else {
            showToast('계정 상태를 확인할 수 없습니다.', 2000);
          }
          ta.blur();
          return false;
        }
        return true;
      }

      async function send(){
        // 로그인 체크
        if (!(await checkLoginAndSend())) return;
        
        const v=ta.value.trim(); if(!v)return;
        addUser(v); ta.value=''; btn.disabled=true;
        
        console.log('[send] Starting API call with message:', v);
        console.log('[send] API_BASE_URL:', API_BASE_URL);
        console.log('[send] isGamePage:', isGamePage, 'GAME_ID:', GAME_ID);
        
        try{ 
          const ans=await askLLM(v,'trpg');
          console.log('[send] Received answer:', ans);
          // 게임 페이지가 아닐 때만 addBot 호출 (게임 페이지는 askLLM 내부에서 처리)
          if (!isGamePage && ans) {
            addBot(ans||'(응답이 비어있습니다)');
          }
        }
        catch(e){ 
          console.error('[send] Error caught:', e);
          addBot('서버 오류: '+e.message);
        }
        finally{ 
          btn.disabled=false; 
          ta.focus(); 
        }
      }
      
      // 입력 필드 포커스 시 계정 상태 체크
      ta.addEventListener('focus', async (ev) => {
        const status = await checkAccountStatus();
        if (!status.ok) {
          ev.preventDefault();
          ta.blur();

          if (status.reason === 'login') {
            showToast('로그인이 필요합니다.', 2000);
          } else if (status.reason === 'lock') {
            showToast('현재 계정이 차단된 상태입니다.', 2000);
          } else if (status.reason === 'use') {
            showToast('현재 사용이 불가한 상태입니다.', 2000);
          } else {
            showToast('계정 상태를 확인할 수 없습니다.', 2000);
          }
        }
      });

      // 클릭 시도 시 계정 상태 체크
      ta.addEventListener('click', async (ev) => {
        const status = await checkAccountStatus();
        if (!status.ok) {
          ev.preventDefault();
          ta.blur();

          if (status.reason === 'login') {
            showToast('로그인이 필요합니다.', 2000);
          } else if (status.reason === 'lock') {
            showToast('현재 계정이 차단된 상태입니다.', 2000);
          } else if (status.reason === 'use') {
            showToast('현재 사용이 불가한 상태입니다.', 2000);
          } else {
            showToast('계정 상태를 확인할 수 없습니다.', 2000);
          }
        }
      });

      btn.onclick=send;
      ta.addEventListener('keydown', ev=>{ 
        if (ev.key==='Enter' && !ev.shiftKey){ 
          ev.preventDefault(); 
          send(); 
        }
      });
    });
  </script>
</body>
</html>


